<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Moss & Stone</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              concrete: '#E0E0E0',
              'concrete-dark': '#C0C0C0',
              moss: '#3A4D1F',
              'moss-light': '#7B924A',
              ink: '#2C2C2C',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              serif: ['"Noto Serif SC"', 'serif'],
            },
          },
        },
      }
    </script>

    <style>
      body {
        background-color: #E0E0E0;
        color: #2C2C2C;
        overflow: hidden; /* 防止 Body 滚动，交由内部容器滚动 */
        touch-action: none;
      }
      
      .noise-bg {
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        pointer-events: none; z-index: 50; opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      .carved-deep {
        color: rgba(44, 44, 44, 0.65) !important;
        text-shadow: 
            0px 1px 0px rgba(255,255,255, 0.6), 
            0px -1px 1px rgba(0,0,0, 0.2) !important;
        transition: all 1s ease-out;
      }

      textarea:focus, input:focus {
        outline: none !important;
        box-shadow: none !important;
        border: none !important;
      }
      
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { 
          -ms-overflow-style: none;
          scrollbar-width: none;
      }

     .jagged-top {
          /* 【细腻撕痕 - 顶部】
             1. viewBox='0 0 12 6'：把画布缩小，细节更丰富。
             2. points：不再是直线，而是高低起伏的随机坐标 (2,0, 4,3, 6,1...)。
             3. 左右延伸 (-1 和 13)：依然保留重叠逻辑，防止竖线缝隙。
          */
          background-image: url("data:image/svg+xml,%3Csvg width='12' height='6' viewBox='0 0 12 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='-1,6 0,4 2,1 4,4 6,2 8,5 10,1 12,4 13,6' fill='%23Fdfdfd'/%3E%3C/svg%3E");
          
          background-position: bottom left;
          /* 尺寸缩小到 12px 宽，让撕痕看起来非常致密、细腻 */
          background-size: 12px 6px; 
          background-repeat: repeat-x;
          width: 100%;
          height: 6px; /* 高度也相应减小 */
      }

      .jagged-bottom {
          /* 【细腻撕痕 - 底部】
             逻辑同上，方向相反。
          */
          background-image: url("data:image/svg+xml,%3Csvg width='12' height='6' viewBox='0 0 12 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='-1,0 0,2 2,5 4,2 6,4 8,1 10,5 12,2 13,0' fill='%23Fdfdfd'/%3E%3C/svg%3E");
          
          background-position: top left;
          background-size: 12px 6px;
          background-repeat: repeat-x;
          width: 100%;
          height: 6px;
      }
      
      .drop-shadow-jagged {
          filter: drop-shadow(4px 4px 10px rgba(0,0,0,0.15));
      }

      /* 庭院滚动容器样式 */
      .courtyard-scroll-container {
          height: 100vh;
          overflow-y: auto;
          scroll-snap-type: y mandatory;
          scroll-behavior: smooth;
      }
      
      .courtyard-page {
          height: 100vh;
          width: 100%;
          scroll-snap-align: start;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden; /* 限制石头拖拽不出界 */
      }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="noise-bg"></div>
    
    <svg style="display: none;">
        <defs>
            <filter id="mossRoughness">
                <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch" />
                <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 1.2 -0.2" />
            </filter>
            <filter id="mossFuzz">
                <feTurbulence type="fractalNoise" baseFrequency="2.5" numOctaves="3" stitchTiles="stitch" />
                <feContrast in="SourceGraphic" mode="linear" slope="2" />
            </filter>
        </defs>
    </svg>

    <script type="text/babel">
        // ==========================================
        // 0. 配置区域
        // ==========================================
        const INSIGHT_DICT = {
            // ... (INSIGHT_DICT 内容保持不变，太长省略) ...
            universal: [
                "石头从不着急赶路。",
                "青苔不懂石头的坚硬，但它懂得拥抱。",
                "山谷没有回音，是因为它在倾听。",
                "有些重量，放下后才能看清形状。",
                "风吹过，痕迹变淡，但石头记得。",
                "此刻的粗糙，是未来圆润的开始。",
                "河流流过，不留痕迹。",
                "看不见的根，比看得见的叶更深。",
                "世界是空旷的，回音全来自自身。",
                "不要慌张，月亮也经常失眠。"
            ],
            comfort: [
                "青苔只在阴影里生长，不必时刻向阳。",
                "雨水归于大海，情绪也终将平静。",
                "允许自己像石头一样，在这个午后静止。",
                "裂缝不是破碎，是光和苔藓的入口。",
                "落叶归根，并不是某种失败。",
                "哪怕是石头，淋雨久了也会变软。",
                "躲在壳里也没关系，蜗牛也是这样长大的。",
                "潮湿的时候，就长一点青苔吧。",
                "不必坚强，像水一样流淌就好。",
                "夜色落下，一切都会变得温柔。"
            ],
            courage: [
                "山不向我走来，我便站住。",
                "悬崖不害怕坠落，它成为了风景。",
                "急流中，只有最重的石头最安静。",
                "风无法撼动扎根的树。",
                "把心变成石头，就不怕硬碰硬。",
                "路没有尽头，只有路口。",
                "去撞击吧，像浪花撞击礁石那样。",
                "所有的墙，最后都会变成门。",
                "野草不需要园丁的允许也能生长。",
                "站直了，影子自然会跟随你。"
            ],
            patience: [
                "花只开一次，但年年准时。",
                "等待也是一种生长，像钟乳石那样。",
                "时间是风，记忆是灰，让它散去。",
                "冬天来了，春天就不会迷路。",
                "旧物比新人更懂沉默。",
                "如果水流不通，那就变成湖泊。",
                "答案像雾，太阳出来就会显现。",
                "不要追赶落日，它明天还会升起。",
                "缘起缘灭，像云聚云散。",
                "有些事，过了一个季节就懂了。"
            ]
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = audioCtx.sampleRate * 2; 
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
        }

        const playSound = (type, volume = 1.0) => {
            const runAudioLogic = () => {
                const t = audioCtx.currentTime;
                const gainNode = audioCtx.createGain();
                gainNode.connect(audioCtx.destination);

                if (type === 'lift') {
                    const source = audioCtx.createBufferSource();
                    source.buffer = noiseBuffer;
                    source.loop = true;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(150, t);
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0, t);
                    gainNode.gain.linearRampToValueAtTime(0.1, t + 0.1); 
                    gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    source.start(t);
                    source.stop(t + 0.35);
                } else if (type === 'drop') {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(90, t);
                    osc.frequency.exponentialRampToValueAtTime(30, t + 0.12);
                    gainNode.gain.setValueAtTime(0.5, t);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
                    osc.connect(gainNode);
                    osc.start(t);
                    osc.stop(t + 0.7);
                } else if (type === 'organize') {
                    const source = audioCtx.createBufferSource();
                    source.buffer = noiseBuffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(500, t);
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.gain.setValueAtTime(0, t);
                    gainNode.gain.linearRampToValueAtTime(0.1, t + 0.02); 
                    gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6); 
                    source.start(t);
                    source.stop(t + 0.7);
                } else if (type === 'carve') {
                    const source = audioCtx.createBufferSource();
                    source.buffer = noiseBuffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass'; 
                    filter.frequency.setValueAtTime(1000, t); 
                    source.connect(filter);
                    filter.connect(gainNode);
                    const peakGain = 0.6 * volume;
                    gainNode.gain.setValueAtTime(0, t);
                    gainNode.gain.linearRampToValueAtTime(peakGain, t + 0.005); 
                    gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.04); 
                    source.start(t);
                    source.stop(t + 0.05);
                }
            };
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => { runAudioLogic(); });
            } else {
                runAudioLogic();
            }
        };

        // ==========================================
        // 1. 工具函数
        // ==========================================
        const { motion, AnimatePresence } = window.Motion || {};
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        const chunkArray = (array, size) => {
            const result = [];
            for (let i = 0; i < array.length; i += size) {
                result.push(array.slice(i, i + size));
            }
            return result;
        };

        const Icons = {
            Sun: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="5"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M4.22 4.22l1.42 1.42"/><path d="M18.36 18.36l1.42 1.42"/><path d="M1 12h2"/><path d="M21 12h2"/><path d="M4.22 19.78l1.42-1.42"/><path d="M18.36 5.64l1.42-1.42"/></svg>,
            Cloud: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>,
            CloudRain: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 13v8"/><path d="M8 13v8"/><path d="M12 15v8"/><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"/></svg>,
            CloudLightning: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 16.326A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 .5 8.973"/><path d="m13 12-3 5h4l-3 5"/></svg>,
            X: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>,
            Trash: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Grid: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
            Broom: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 2l-4 14"/><path d="M2 16h20"/><path d="M6 16v6"/><path d="M10 16v6"/><path d="M14 16v6"/><path d="M18 16v6"/></svg>
        };

        const Decorations = {
            Lantern: () => (
                <g opacity="0.6">
                    <path d="M40 100 L60 100 L55 80 L45 80 Z" fill="#2C2C2C" />
                    <path d="M48 80 L52 80 L52 60 L48 60 Z" fill="#2C2C2C" />
                    <path d="M35 60 L65 60 L60 40 L40 40 Z" fill="#2C2C2C" />
                    <path d="M30 40 Q50 20 70 40 L30 40" fill="#2C2C2C" />
                    <circle cx="50" cy="35" r="3" fill="#E0E0E0" />
                    <circle cx="50" cy="50" r="8" fill="#F9A825" opacity="0.3" filter="url(#mossFuzz)" />
                </g>
            ),
            Pine: () => (
                <g>
                    <path d="M55 145 L45 145 Q40 120 50 100 Q35 90 30 75 Q45 80 55 90 Q60 70 55 50 L60 50 Q70 80 75 100 Q65 120 55 145 Z" fill="#2C2C2C" opacity="0.9" />
                    <path d="M55 90 Q75 95 90 85" stroke="#2C2C2C" strokeWidth="3" fill="none" strokeLinecap="round" />
                    <path d="M50 100 Q35 105 20 95" stroke="#2C2C2C" strokeWidth="2.5" fill="none" strokeLinecap="round" />
                    <path d="M55 50 Q50 35 60 20" stroke="#2C2C2C" strokeWidth="2" fill="none" strokeLinecap="round" />
                    <circle cx="90" cy="85" r="14" fill="#3A4D1F" opacity="0.8" filter="url(#mossRoughness)" />
                    <circle cx="85" cy="80" r="10" fill="#1a260e" opacity="0.5" filter="url(#mossRoughness)" />
                    <circle cx="20" cy="95" r="12" fill="#3A4D1F" opacity="0.8" filter="url(#mossRoughness)" />
                    <circle cx="60" cy="20" r="15" fill="#3A4D1F" opacity="0.9" filter="url(#mossRoughness)" />
                    <circle cx="50" cy="25" r="10" fill="#7B924A" opacity="0.6" filter="url(#mossRoughness)" />
                    <circle cx="50" cy="60" r="8" fill="#3A4D1F" opacity="0.7" filter="url(#mossRoughness)" />
                </g>
            ),
            Bamboo: () => (
                <g>
                    <path d="M65 145 Q70 100 68 30" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.4" strokeLinecap="round" />
                    <path d="M66 110 L70 109" stroke="#2C2C2C" strokeWidth="1" opacity="0.3" />
                    <path d="M67 70 L71 69" stroke="#2C2C2C" strokeWidth="1" opacity="0.3" />
                    <path d="M35 150 Q30 90 38 40" stroke="#3A4D1F" strokeWidth="3" fill="none" opacity="0.7" strokeLinecap="round" />
                    <path d="M30 120 L40 118" stroke="#2C2C2C" strokeWidth="1.5" opacity="0.6" />
                    <path d="M32 80 L42 78" stroke="#2C2C2C" strokeWidth="1.5" opacity="0.6" />
                    <path d="M50 155 Q52 80 48 10" stroke="#2C2C2C" strokeWidth="4" fill="none" opacity="0.85" strokeLinecap="round" />
                    <path d="M45 125 L56 123" stroke="#2C2C2C" strokeWidth="2" />
                    <path d="M46 90 L57 88" stroke="#2C2C2C" strokeWidth="2" />
                    <path d="M47 55 L58 53" stroke="#2C2C2C" strokeWidth="2" />
                    <path d="M48 20 L35 25 M48 20 L55 10 M48 20 L60 25" stroke="#3A4D1F" strokeWidth="2" fill="none" />
                    <path d="M38 40 L25 45 M38 40 L28 30" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.8" />
                    <path d="M46 90 L60 95 M46 90 L65 85" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.8" />
                    <path d="M30 120 L20 125" stroke="#3A4D1F" strokeWidth="1.5" fill="none" opacity="0.6" />
                </g>
            )
        };

        const ScreenState = {
            COURTYARD: 'COURTYARD',
            ETCHING: 'ETCHING',
            OVERGROWTH: 'OVERGROWTH',
            ECHO: 'ECHO'
        };

        const Weather = {
            SUN: 'Sun',
            CLOUD: 'Cloud',
            RAIN: 'Rain',
            STORM: 'Storm'
        };

        const generateOrganicShape = () => {
            const r = () => 30 + Math.random() * 40; 
            return `${r()}% ${r()}% ${r()}% ${r()}% / ${r()}% ${r()}% ${r()}% ${r()}%`;
        };

        const generateInsight = async (text, weatherType) => {
            return new Promise(resolve => {
                const thinkTime = 1500 + Math.random() * 1200;
                
                setTimeout(() => {
                    const t = (text || "").toLowerCase();
                    let hash = 0;
                    for (let i = 0; i < t.length; i++) {
                        const char = t.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; 
                    }
                    const seed = Math.abs(hash); 

                    const dict = {
                        negations: ["不", "没", "非", "别", "无", "not", "no", "don't"],
                        emotions: {
                            negative: ["累", "痛", "苦", "哭", "烦", "死", "糟", "烂", "丧", "病", "难", "累", "倦", "sad", "bad", "tired"],
                            fear: ["怕", "慌", "恐", "吓", "避", "逃", "不敢", "担心", "afraid", "fear"],
                            confused: ["迷", "惑", "乱", "晕", "不懂", "不知", "怀疑", "lost", "confused"]
                        },
                        topics: {
                            love: ["爱", "情", "他", "她", "你", "想", "念", "分", "离", "前任", "友", "家", "love", "miss"],
                            work: ["职", "工", "作", "钱", "穷", "忙", "业", "考", "学", "板", "户", "work", "job", "money"],
                            self: ["我", "己", "人", "命", "运", "性格", "自", "self", "life"]
                        }
                    };

                    const has = (keywords) => {
                        return keywords.some(k => {
                            const idx = t.indexOf(k);
                            if (idx === -1) return false;
                            const prev2Chars = t.substring(Math.max(0, idx - 2), idx);
                            const isNegated = dict.negations.some(n => prev2Chars.includes(n));
                            return !isNegated; 
                        });
                    };

                    let category = null;

                    if (has(dict.topics.work) && (has(dict.emotions.negative) || has(dict.emotions.fear))) {
                        category = (seed % 2 === 0) ? "comfort" : "courage";
                    }
                    else if (has(dict.topics.love) && (has(dict.emotions.negative) || has(dict.emotions.confused))) {
                        category = "patience";
                    }
                    else if (has(dict.topics.self) && has(dict.emotions.confused)) {
                        category = "courage";
                    }
                    else if (has(dict.emotions.negative)) category = "comfort";
                    else if (has(dict.emotions.fear)) category = "courage";
                    else if (has(dict.emotions.confused)) category = "patience";
                    else {
                        if (weatherType === 'Rain') category = "comfort";
                        else if (weatherType === 'Cloud') category = "patience";
                        else category = "universal";
                    }
                    
                    let pool = [...INSIGHT_DICT[category || "universal"]];
                    if (category && category !== "universal") {
                        pool = [...pool, ...INSIGHT_DICT.universal];
                    }
                    
                    const daySeed = new Date().getDate() + new Date().getHours();
                    const finalIndex = (seed + daySeed) % pool.length;
                    
                    resolve(pool[finalIndex]);

                }, thinkTime);
            });
        };

        const Stone = ({ shape, size = 'md', isMossy = false, className = '', onClick, children, style }) => {
            const sizeClasses = {
                sm: 'w-16 h-16',
                md: 'w-32 h-32',
                lg: 'w-80 h-80' 
            };
            const thickShadowStyle = `
                inset 2px 2px 10px rgba(255,255,255, 0.8), 
                inset -3px -3px 15px rgba(0,0,0, 0.25), 
                0px 5px 5px rgba(0,0,0, 0.15), 
                0px 12px 20px rgba(0,0,0, 0.1), 
                0px 25px 40px rgba(0,0,0, 0.1)
            `;

            return (
                <div onClick={onClick} className={`relative bg-[#d4d4d4] overflow-hidden cursor-grab active:cursor-grabbing transition-all duration-300 ease-out ${sizeClasses[size]} ${className}`} style={{ borderRadius: shape, boxShadow: thickShadowStyle, transform: 'translateZ(0) perspective(500px) rotateX(2deg)', backfaceVisibility: 'hidden', ...style }}>
                    <div className="absolute inset-0 opacity-20 pointer-events-none z-0" style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")` }}></div>
                    {isMossy && (
                        <>
                            <div className="absolute inset-0 z-10 opacity-70 mix-blend-multiply pointer-events-none" style={{ backgroundColor: '#4A5D23', filter: 'url(#mossRoughness) contrast(1.2)', transform: 'scale(1.02)' }}></div>
                            <div className="absolute inset-0 z-10 opacity-60 mix-blend-overlay pointer-events-none" style={{ backgroundColor: '#8A9A5B', backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")`, boxShadow: 'inset 5px 5px 20px rgba(255,255,255,0.3)' }}></div>
                             <div className="absolute inset-0 z-10 pointer-events-none opacity-40 mix-blend-multiply" style={{ background: 'radial-gradient(circle at 30% 30%, transparent 40%, #1a260e 100%)' }}></div>
                        </>
                    )}
                    <div className="relative z-20 w-full h-full">{children}</div>
                </div>
            );
        };

        // ==========================================
        // 3. 核心页面组件 - Courtyard
        // ==========================================
        const Courtyard = ({ stones, onStart, onUpdateStones, gardenItems, onTransform }) => {
            const [windowSize, setWindowSize] = useState({ w: window.innerWidth, h: window.innerHeight });

            useEffect(() => {
                const handleResize = () => setWindowSize({ w: window.innerWidth, h: window.innerHeight });
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const xLimit = windowSize.w / 2 - 60;
            const yLimit = windowSize.h / 2 - 90;

            const [isSelectorOpen, setIsSelectorOpen] = useState(false);
            const [selectedStone, setSelectedStone] = useState(null);
            const [currentPageIndex, setCurrentPageIndex] = useState(0);
            const [showClearConfirm, setShowClearConfirm] = useState(false);
            const [showTransformConfirm, setShowTransformConfirm] = useState(false);
            const [showNotReadyTip, setShowNotReadyTip] = useState(false);

            const isDraggingRef = useRef(false);
            const scrollContainerRef = useRef(null);
            const pageRefs = useRef([]);

            const stoneChunks = useMemo(() => {
                const sorted = [...stones]; 
                const chunks = chunkArray(sorted, 9);
                if (chunks.length === 0) chunks.push([]);
                while (chunks.length <= currentPageIndex) {
                    chunks.push([]);
                }
                return chunks;
            }, [stones, currentPageIndex]);

            const currentChunk = stoneChunks[currentPageIndex] || [];

            const smoothScrollTo = (element, target, duration) => {
                const start = element.scrollTop;
                const change = target - start;
                const startTime = performance.now();
                element.style.scrollSnapType = 'none';
                const animateScroll = (currentTime) => {
                    const timeElapsed = currentTime - startTime;
                    if (timeElapsed < duration) {
                        const progress = timeElapsed / duration;
                        const ease = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                        element.scrollTop = start + (change * ease);
                        requestAnimationFrame(animateScroll);
                    } else {
                        element.scrollTop = target;
                        element.style.scrollSnapType = 'y mandatory';
                    }
                };
                requestAnimationFrame(animateScroll);
            };

            useEffect(() => {
                if (stoneChunks.length > 1) {
                    const lastPageIndex = stoneChunks.length - 1;
                    const container = scrollContainerRef.current;
                    if (container) {
                        const pageHeight = container.clientHeight;
                        const targetScrollTop = lastPageIndex * pageHeight;
                        const prevPageScrollTop = (lastPageIndex - 1) * pageHeight;
                        container.style.scrollBehavior = 'auto'; 
                        if (container.scrollTop < 10) container.scrollTop = prevPageScrollTop;
                        smoothScrollTo(container, targetScrollTop, 1500); 
                    }
                }
            }, [stones.length, stoneChunks.length]);

            const weatherOptions = [
                { type: Weather.SUN, icon: Icons.Sun, label: "晴朗" },
                { type: Weather.CLOUD, icon: Icons.Cloud, label: "多云" },
                { type: Weather.RAIN, icon: Icons.CloudRain, label: "雨天" },
                { type: Weather.STORM, icon: Icons.CloudLightning, label: "风暴" },
            ];

            const formatDate = (timestamp) => {
                const date = new Date(timestamp);
                const Y = date.getFullYear();
                const M = (date.getMonth() + 1).toString().padStart(2, '0');
                const D = date.getDate().toString().padStart(2, '0');
                const h = date.getHours().toString().padStart(2, '0');
                const m = date.getMinutes().toString().padStart(2, '0');
                return `${Y}年${M}月${D}日 ${h}:${m}`;
            };

            const handleScroll = () => {
                if (!scrollContainerRef.current) return;
                const scrollTop = scrollContainerRef.current.scrollTop;
                const height = scrollContainerRef.current.clientHeight;
                const index = Math.round(scrollTop / height);
                setCurrentPageIndex(index);
            };

            const handleDragEnd = (stoneId, info) => {
                const delta = { x: info.offset.x, y: info.offset.y };
                onUpdateStones(prev => prev.map(s => {
                    if (s.id === stoneId) {
                        let newX = (s.x || 0) + delta.x;
                        let newY = (s.y || 0) + delta.y;
                        newX = Math.max(-xLimit, Math.min(newX, xLimit));
                        newY = Math.max(-yLimit, Math.min(newY, yLimit));
                        return { ...s, x: newX, y: newY };
                    }
                    return s;
                }));
            };

            const handleOrganize = () => {
                playSound('organize');
                if(currentChunk.length === 0) return;
                const gridGap = 110; 
                const startX = -110; 
                const startY = -120; 
                const updates = {};
                currentChunk.forEach((stone, index) => {
                    const row = Math.floor(index / 3);
                    const col = index % 3;
                    updates[stone.id] = { x: startX + col * gridGap, y: startY + row * gridGap, rotation: 0 };
                });
                onUpdateStones(prev => prev.map(s => updates[s.id] ? { ...s, ...updates[s.id] } : s));
            };

            const handleClear = (type) => {
                if (type === 'current') {
                    const stonesToRemove = currentChunk.map(s => s.id);
                    onUpdateStones(prev => prev.filter(s => !stonesToRemove.includes(s.id)));
                } else if (type === 'all') {
                    onUpdateStones([]);
                }
                setShowClearConfirm(false);
            };

            const handleTransformationClick = () => {
                if (currentChunk.length >= 9) {
                    setShowTransformConfirm(true);
                } else {
                    setShowNotReadyTip(true);
                    setTimeout(() => setShowNotReadyTip(false), 2000);
                }
            };

            const getPageDateRange = (chunk) => {
                if (!chunk || chunk.length === 0) return "";
                const fmt = (ts) => {
                    const d = new Date(ts);
                    return `${d.getFullYear()}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`;
                };
                const startStr = fmt(chunk[0].timestamp);
                const endStr = fmt(chunk[chunk.length - 1].timestamp);
                return startStr === endStr ? startStr : `${startStr} - ${endStr}`;
            };

            return (
                <div className="relative w-full h-full">
                    <header className="absolute top-4 left-0 w-full text-center z-20 pointer-events-none">
                        <h1 className="text-3xl font-serif font-bold text-ink opacity-80">苔与石</h1>
                        <p className="text-xs text-ink/60 mt-2 tracking-[0.2em] uppercase">Moss & Stone</p>
                        {stones.length > 0 && (
                            <div className="absolute top-2 right-[-60px] md:right-[-100px] text-[10px] text-ink/20 font-sans">
                                本页: {currentChunk.length}/9
                            </div>
                        )}
                    </header>

                    <button
                        onClick={() => {
                            const newStone = {
                                id: `debug-${Date.now()}`,
                                worry: `测试数据 ${stones.length + 1}`,
                                insight: `测试数据：青苔不懂石头的坚硬。`,
                                timestamp: Date.now(),
                                weather: 'Sun',
                                shapePolygon: generateOrganicShape(), 
                                rotation: Math.random() * 30 - 15,
                                x: Math.random() * 160 - 80, 
                                y: Math.random() * 160 - 80
                            };
                            onUpdateStones(prev => [...prev, newStone]);
                        }}
                        className="absolute bottom-4 right-4 z-50 px-4 py-2 bg-red-500/10 border border-red-500/30 text-red-800/60 text-xs font-bold rounded hover:bg-red-500/20 transition-colors backdrop-blur-md"
                    >
                        [测试] +1
                    </button>

                    {stones.length > 0 && (
                        <div className="absolute top-6 right-6 z-30 flex flex-col gap-4 items-center">
                            <button onClick={handleOrganize} className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-moss transition-all shadow-sm backdrop-blur-sm" title="整理">
                                <Icons.Grid size={20} />
                            </button>
                            <button onClick={() => setShowClearConfirm(true)} className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-red-800 transition-all shadow-sm backdrop-blur-sm" title="清扫">
                                <Icons.Broom size={20} />
                            </button>
                            <AnimatePresence>
                                {currentChunk.length >= 8 && (
                                    <div className="relative">
                                        <motion.button
                                            initial={{ scale: 0, opacity: 0 }}
                                            animate={{ 
                                                scale: 1, 
                                                opacity: 1,
                                                boxShadow: currentChunk.length >= 9 
                                                    ? "0 0 15px rgba(58, 77, 31, 0.5), inset 0 0 10px rgba(255,255,255,0.3)" 
                                                    : "none"
                                            }}
                                            exit={{ scale: 0, opacity: 0 }} 
                                            transition={{ type: "spring", stiffness: 300, damping: 20 }}
                                            whileHover={{ scale: 1.1 }}
                                            whileTap={{ scale: 0.9 }}
                                            onClick={handleTransformationClick}
                                            className={`
                                                w-10 h-10 rounded-full flex items-center justify-center 
                                                backdrop-blur-md border border-white/30 shadow-lg
                                                transition-all duration-500
                                                ${currentChunk.length >= 9 
                                                    ? "bg-moss text-white/90 animate-pulse" 
                                                    : "bg-moss/20 text-moss/50" 
                                                }
                                            `}
                                        >
                                            <span className="text-sm">⭕</span>
                                        </motion.button>
                                        <AnimatePresence>
                                            {showNotReadyTip && (
                                                <motion.div
                                                    initial={{ opacity: 0, x: -10 }}
                                                    animate={{ opacity: 1, x: -50 }}
                                                    exit={{ opacity: 0 }}
                                                    className="absolute top-1/2 -translate-y-1/2 right-0 whitespace-nowrap pointer-events-none"
                                                >
                                                    <div className="bg-ink/80 text-white text-[10px] px-2 py-1 rounded-md shadow-sm font-serif">
                                                        还剩 {9 - currentChunk.length} 个苔石解锁
                                                    </div>
                                                </motion.div>
                                            )}
                                        </AnimatePresence>
                                    </div>
                                )}
                            </AnimatePresence>
                        </div>
                    )}

                    <div ref={scrollContainerRef} onScroll={handleScroll} className="courtyard-scroll-container no-scrollbar relative">
                        {stoneChunks.map((chunk, pageIndex) => (
                            <div key={pageIndex} ref={el => pageRefs.current[pageIndex] = el} className="courtyard-page">
                                <div className="relative w-[340px] h-[340px] md:w-[500px] md:h-[500px]">
                                    <AnimatePresence>
                                        {chunk.map((stone, i) => (
                                            <motion.div 
                                                key={stone.id} 
                                                drag
                                                whileDrag={{ scale: 1.05 }} 
                                                dragMomentum={false}
                                                dragElastic={0}
                                                onPointerDown={() => { if (audioCtx.state === 'suspended') audioCtx.resume(); }}
                                                onDragStart={() => { isDraggingRef.current = true; playSound('lift'); }}
                                                onDragEnd={(e, info) => { handleDragEnd(stone.id, info); playSound('drop'); setTimeout(() => isDraggingRef.current = false, 200); }}
                                                onClick={(e) => {
                                                    if (isDraggingRef.current) { e.stopPropagation(); return; }
                                                    if (!isSelectorOpen && !selectedStone) setSelectedStone(stone);
                                                }}
                                                transition={{ type: "spring", stiffness: 400, damping: 25 }}
                                                dragConstraints={{ left: -xLimit, right: xLimit, top: -yLimit, bottom: yLimit }}
                                                initial={{ scale: 0 }}
                                                animate={{ scale: 1, x: stone.x || 0, y: stone.y || 0, rotate: stone.rotation, opacity: 1, filter: 'blur(0px)' }}
                                                exit={{ opacity: 0, scale: 0.9, y: (stone.y || 0) + 120, filter: 'blur(10px)', transition: { duration: 1.5, ease: "easeInOut", delay: i * 0.08 } }}
                                                className="absolute left-1/2 top-1/2 -ml-8 -mt-8"
                                                style={{ zIndex: 10 }}
                                            >
                                                <Stone shape={stone.shapePolygon} isMossy size="sm" className="hover:scale-105 transition-transform duration-300 shadow-lg" />
                                            </motion.div>
                                        ))}
                                    </AnimatePresence>
                                    {pageIndex === stoneChunks.length - 1 && !isSelectorOpen && !selectedStone && (
                                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none translate-y-64">
                                            <motion.button
                                                initial={{ opacity: 0, scale: 0.9 }}
                                                animate={{ opacity: 1, scale: 1 }}
                                                whileHover={{ scale: 1.02, rotate: 2 }}
                                                whileTap={{ scale: 0.98 }}
                                                onClick={() => setIsSelectorOpen(true)}
                                                className="w-48 h-32 border-4 border-dashed border-ink/10 rounded-[40%_60%_50%_50%/50%_40%_60%_50%] flex items-center justify-center hover:border-ink/30 transition-colors bg-concrete/20 pointer-events-auto"
                                            >
                                                <span className="text-2xl text-ink/20">+</span>
                                            </motion.button>
                                        </div>
                                    )}
                                </div>
                                <div className="absolute bottom-8 left-0 w-full text-center pointer-events-none">
                                    <p className="text-[10px] font-sans font-bold tracking-[0.15em] text-ink/20 mb-1.5 uppercase">{getPageDateRange(chunk)}</p>
                                    <p className="text-xs text-ink/30 font-serif tracking-widest">{pageIndex === stoneChunks.length - 1 ? "把心事，放在这里。" : "往事已生青苔。" }</p>
                                    {stoneChunks.length > 1 && (
                                        <div className="mt-2 flex justify-center gap-1">
                                            {stoneChunks.map((_, i) => (
                                                <div key={i} className={`w-1.5 h-1.5 rounded-full ${i === currentPageIndex ? 'bg-moss' : 'bg-ink/10'}`} />
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>

                    <div className="absolute inset-0 z-10 overflow-hidden pointer-events-none"> 
                        {gardenItems && gardenItems.map(item => {
                            const Component = Decorations[item.type];
                            return (
                                <motion.div
                                    key={item.id}
                                    drag 
                                    dragMomentum={false} 
                                    initial={{ opacity: 0, scale: 0 }}
                                    animate={{ opacity: 1, scale: item.scale }}
                                    transition={{ duration: 2, ease: "easeOut" }}
                                    className="absolute cursor-move pointer-events-auto" 
                                    style={{
                                        left: `${item.x}%`,
                                        top: `${item.y}%`,
                                        filter: 'blur(1px) drop-shadow(0 4px 6px rgba(0,0,0,0.1))'
                                    }}
                                >
                                    <svg width="100" height="150" viewBox="0 0 100 150">
                                        <Component />
                                    </svg>
                                </motion.div>
                            );
                        })}
                    </div>

                    <AnimatePresence>
                        {isSelectorOpen && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm">
                                <motion.div initial={{ y: 50, opacity: 0 }} animate={{ y: 0, opacity: 1 }} exit={{ y: 50, opacity: 0 }} className="bg-[#E8E8E8] p-8 rounded-3xl shadow-2xl w-80 max-w-sm border border-white/40">
                                    <h3 className="text-center text-ink/70 mb-8 font-serif text-lg">此刻内心的天气？</h3>
                                    <div className="flex justify-between px-2 mb-4">
                                        {weatherOptions.map((option) => (
                                            <button key={option.type} onClick={() => { setIsSelectorOpen(false); onStart(option.type); }} className="flex flex-col items-center gap-3 text-ink/40 hover:text-moss transition-colors group">
                                                <div className="p-3 rounded-full bg-white/50 group-hover:bg-white transition-colors shadow-sm"><option.icon size={24} /></div>
                                                <span className="text-xs font-serif">{option.label}</span>
                                            </button>
                                        ))}
                                    </div>
                                    <button onClick={() => setIsSelectorOpen(false)} className="w-full mt-8 text-xs text-ink/30 tracking-widest hover:text-ink py-2">取消</button>
                                </motion.div>
                            </div>
                        )}
                    </AnimatePresence>
                    
                    <AnimatePresence>
                        {selectedStone && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm" onClick={() => setSelectedStone(null)}>
                                <motion.div initial={{ scale: 0.95, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.95, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F0F0F0] p-8 rounded-2xl shadow-2xl w-80 max-w-sm border border-white/40 relative text-center m-4">
                                    <button onClick={() => setSelectedStone(null)} className="absolute top-4 right-4 text-ink/30 hover:text-ink transition-colors"><Icons.X size={20} /></button>
                                    <div className="mt-4 mb-8">
                                        <p className="text-xs text-ink/40 font-serif tracking-widest uppercase mb-4">{formatDate(selectedStone.timestamp)}</p>
                                        <div className="w-8 h-1 bg-moss/20 mx-auto mb-8 rounded-full"></div>
                                        <p className="font-serif text-xl text-ink leading-loose">“{selectedStone.insight}”</p>
                                    </div>
                                    <div className="pt-6 border-t border-ink/5"><p className="text-xs text-moss opacity-60 font-serif tracking-widest">记忆已模糊，但智慧留存。</p></div>
                                </motion.div>
                            </div>
                        )}
                    </AnimatePresence>

                     <AnimatePresence>
                        {showClearConfirm && (
                            <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/10 backdrop-blur-sm" onClick={() => setShowClearConfirm(false)}>
                                <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F0F0F0] p-6 rounded-2xl shadow-xl w-72 text-center border border-white/50">
                                    <h4 className="text-ink/80 font-serif font-bold mb-4">清扫庭院</h4>
                                    <p className="text-xs text-ink/50 mb-6 font-serif">要扫去哪些记忆？</p>
                                    <div className="flex flex-col gap-3">
                                        <button onClick={() => handleClear('current')} className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-ink/70 text-sm hover:bg-moss/10 hover:text-moss transition-colors">仅清扫当前页面</button>
                                        <button onClick={() => handleClear('all')} className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-red-800/60 text-sm hover:bg-red-50 hover:text-red-800 transition-colors">清空所有</button>
                                        <button onClick={() => setShowClearConfirm(false)} className="mt-2 text-xs text-ink/30 hover:text-ink/60 transition-colors">取消</button>
                                    </div>
                                </motion.div>
                            </div>
                        )}
                    </AnimatePresence>

                    <AnimatePresence>
                        {showTransformConfirm && (
                            <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/20 backdrop-blur-sm" onClick={() => setShowTransformConfirm(false)}>
                                <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F4F4F4] p-8 rounded-2xl shadow-2xl w-80 text-center border-2 border-moss/10">
                                    <div className="mb-6 text-4xl opacity-80">⭕</div>
                                    <h4 className="text-moss font-serif font-bold text-lg mb-2">庭院仪式</h4>
                                    <p className="text-xs text-ink/60 mb-8 font-serif leading-relaxed">
                                        这一页的 9 份记忆已经填满。<br/>
                                        愿意将它们化作<br/>
                                        庭院里永恒的风景吗？
                                    </p>
                                    <button 
                                        onClick={() => { 
                                            onTransform(currentChunk.map(s => s.id)); 
                                            setShowTransformConfirm(false); 
                                        }} 
                                        className="w-full py-3 rounded-lg bg-moss text-white text-sm tracking-widest hover:bg-moss-light transition-all shadow-lg mb-3"
                                    >
                                        放下，并转化
                                    </button>
                                    <button onClick={() => setShowTransformConfirm(false)} className="text-xs text-ink/30 hover:text-ink/60 transition-colors">我还想留着~</button>
                                </motion.div>
                            </div>
                        )}
                    </AnimatePresence>
                </div>
            );
        };
        // 4. Etching, Overgrowth, Echo 等组件
        const Etching = ({ stoneShape, onLayDown }) => {
            const [text, setText] = useState('');
            const [isCarving, setIsCarving] = useState(false);
            const [carvedIndex, setCarvedIndex] = useState(0); 
            const textareaRef = useRef(null);
            const scrollRef = useRef(null);

            useEffect(() => {
                const timer = setTimeout(() => {
                    if (textareaRef.current) textareaRef.current.focus();
                }, 850);
                return () => clearTimeout(timer);
            }, []);

            useEffect(() => {
                if (isCarving && scrollRef.current) {
                    const element = scrollRef.current;
                    const isOverflowing = element.scrollHeight > element.clientHeight;
                    if (isOverflowing) {
                        element.scrollTop = element.scrollHeight;
                    }
                }
            }, [carvedIndex, isCarving]);

            useEffect(() => {
                if (!isCarving) return;

                if (carvedIndex >= text.length) {
                    const finishTimer = setTimeout(() => {
                        onLayDown(text);
                    }, 500);
                    return () => clearTimeout(finishTimer);
                }

                let delay;
                const maxDelay = 450; 
                const minDelay = 20;  
                const accelerationStart = 2; 

                if (carvedIndex < accelerationStart) {
                    delay = maxDelay;
                } else {
                    const x = carvedIndex - accelerationStart; 
                    const decayFactor = 0.12; 
                    delay = Math.max(
                        minDelay, 
                        maxDelay * Math.pow(Math.E, -decayFactor * x)
                    );
                    const jitter = (Math.random() * 10) - 5;
                    delay = Math.round(delay + jitter);
                }                        

                const timer = setTimeout(() => {
                    setCarvedIndex(prev => prev + 1);
                    const safeIndex = Math.min(carvedIndex, text.length - 1);
                    const currentChar = text[safeIndex] || ""; 
                    const isSilentChar = /\s/.test(currentChar);
                    const volumeProfile = [
                        1.00, 0.85, 0.70, 0.55, 
                        0.37, 0.28, 0.24, 0.20, 0.16, 
                        0.12, 0.10, 0.08, 0.04, 0.03, 0.01
                    ];
                    let currentVol = 0;
                    if (carvedIndex < volumeProfile.length) {
                        currentVol = volumeProfile[carvedIndex];
                    }

                    if (currentVol > 0 && !isSilentChar && isFinite(currentVol)) {
                        playSound('carve', currentVol); 
                    }

                }, delay);

                return () => clearTimeout(timer);
            }, [isCarving, carvedIndex, text, onLayDown]);

            const handleSubmit = () => {
                if (text.trim().length === 0) return;
                
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                const dummyOsc = audioCtx.createOscillator();
                const dummyGain = audioCtx.createGain();
                dummyGain.gain.value = 0; 
                dummyOsc.connect(dummyGain);
                dummyGain.connect(audioCtx.destination);
                dummyOsc.start();
                dummyOsc.stop(0.1);

                if (textareaRef.current) textareaRef.current.blur();
                
                setTimeout(() => {
                    setIsCarving(true); 
                    setCarvedIndex(0); 
                }, 10); 
            };

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} transition={{ duration: 0.8, ease: "easeOut" }} className="relative">
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-20">
                                {!isCarving && (
                                    <textarea
                                        ref={textareaRef}
                                        value={text}
                                        onChange={(e) => setText(e.target.value)}
                                        placeholder="刚才发生了什么？"
                                        maxLength={130}
                                        spellCheck={false}
                                        autoComplete="off"
                                        style={{ textShadow: '0px 1px 0px rgba(255,255,255,0.5)', caretColor: '#2C2C2C', outline: 'none', border: 'none', boxShadow: 'none', resize: 'none' }}
                                        className="no-scrollbar appearance-none border-0 shadow-none w-[75%] h-[55%] py-4 bg-transparent text-center text-[#333] font-serif text-lg leading-relaxed placeholder:text-ink/30 placeholder:italic placeholder:shadow-none overflow-y-auto focus:ring-0"
                                    />
                                )}
                                {isCarving && (
                                    <div 
                                        ref={scrollRef}
                                        style={{ transform: 'translateZ(0)', maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)', WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)' }}
                                        className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-y-auto scroll-smooth"
                                    >
                                        {text.split('').map((char, index) => (
                                            <span key={index} className={index < carvedIndex ? "carved-deep" : "opacity-0"} style={{ transition: 'opacity 0.1s' }}>{char}</span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex flex-col items-center pt-12">
                            <motion.button initial={{ opacity: 0 }} animate={{ opacity: text.length > 0 && !isCarving ? 1 : 0 }} disabled={text.length === 0 || isCarving} onClick={handleSubmit} className="px-8 py-3 bg-transparent border border-ink/20 rounded-full text-ink/60 tracking-widest text-sm font-serif hover:bg-ink/5 transition-all disabled:opacity-0 focus:outline-none focus:ring-0 whitespace-nowrap">{isCarving ? "刻录中..." : "刻好了，放下吧"}</motion.button>
                            {!isCarving && (
                                <div className="mt-4 text-ink/20 text-xs italic font-serif">
                                    {text.length}/130
                                </div>
                            )}
                        </div>
                    </motion.div>
                </div>
            );
        };

        const Overgrowth = ({ worry, stoneShape, onGrowthComplete }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onGrowthComplete();
                }, 5000); 
                return () => clearTimeout(timer);
            }, [onGrowthComplete]);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div className="relative">
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-0">
                                <motion.div initial={{ opacity: 0.8 }} animate={{ opacity: 0 }} transition={{ duration: 2, delay: 1 }} style={{ transform: 'translateZ(0)', maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)', WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)' }} className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-hidden pointer-events-none">
                                    <span className="carved-deep w-full">{worry}</span>
                                </motion.div>
                            </div>
                            <motion.div initial={{ opacity: 0, scale: 1.1 }} animate={{ opacity: 0.7, scale: 1 }} transition={{ duration: 4, ease: "easeOut", delay: 0.5 }} className="absolute inset-0 z-30 mix-blend-multiply" style={{ borderRadius: stoneShape, backgroundColor: '#4A5D23', filter: 'url(#mossRoughness)' }} />
                            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 0.6 }} transition={{ duration: 3, delay: 1.8 }} className="absolute inset-0 z-40 mix-blend-overlay" style={{ borderRadius: stoneShape, backgroundColor: '#8A9A5B', backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")` }} />
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex justify-center pt-12">
                            <motion.p initial={{ opacity: 0 }} animate={{ opacity: [0, 1, 0] }} transition={{ duration: 4, times: [0, 0.5, 1] }} className="text-moss text-sm font-serif whitespace-nowrap">正在回归大地...</motion.p>
                        </div>
                    </motion.div>
                </div>
            );
        };

        const Echo = ({ insight, stoneShape, onReturn }) => {
            const randomID = useMemo(() => Math.random().toString(36).substring(2, 8).toUpperCase(), []);
            const currentDate = useMemo(() => {
                const d = new Date();
                return `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear().toString().substr(-2)} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }, []);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 bg-black/5 overflow-hidden relative">
                    <motion.div initial={{ scale: 1.5, y: 0, opacity: 1 }} animate={{ scale: 0.6, y: -120, opacity: 0.8 }} transition={{ duration: 1.5, type: "spring", bounce: 0.2 }} className="absolute pointer-events-none grayscale opacity-10 z-0">
                        <Stone shape={stoneShape} isMossy size="md" />
                    </motion.div>
                    <motion.div drag dragConstraints={{ left: -100, right: 100, top: -100, bottom: 100 }} whileDrag={{ scale: 1, rotate: 0 }} dragElastic={0.1} initial={{ opacity: 0, y: 20, rotate: -5 }} animate={{ opacity: 1, y: 20, rotate: 1 }} transition={{ delay: 0.5, duration: 0.8, type: "spring" }} className="relative z-20 bg-[#Fdfdfd] text-ink w-64 max-w-sm drop-shadow-jagged cursor-grab active:cursor-grabbing" style={{ transformOrigin: "center center" }}>
                        <div className="absolute top-[-8px] left-0 w-full h-[8px] jagged-top"></div>
                        <div className="absolute bottom-[-8px] left-0 w-full h-[8px] jagged-bottom"></div>
                        <button onClick={onReturn} className="absolute top-2 right-2 text-ink/40 hover:text-red-500 transition-colors z-30 p-2"><Icons.X size={16} /></button>
                        <div className="p-5 pb-6 font-sans">
                            <div className="text-center mb-4">
                                <h3 className="text-xs font-bold tracking-[0.2em] uppercase text-ink/80">Pager Message</h3>
                            </div>
                            <div className="flex justify-between items-end text-[9px] text-ink/50 mb-2 font-bold tracking-wide">
                                <span>ID: {randomID}</span>
                                <span>{currentDate}</span>
                            </div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-4"></div>
                            <div className="min-h-[100px] flex items-center justify-center">
                                <p className="text-base font-bold leading-relaxed text-ink text-left w-full select-none" style={{ textWrap: 'balance' }}>{insight}</p>
                            </div>
                            <div className="h-4"></div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-3"></div>
                            <div className="flex justify-between items-center opacity-60">
                                <div className="flex items-end gap-[2px] h-6 overflow-hidden">
                                    {[...Array(15)].map((_, i) => (
                                        <div key={i} className="bg-ink" style={{ width: Math.random() > 0.6 ? '1px' : '2px', height: '100%' }}></div>
                                    ))}
                                </div>
                                <span className="text-[8px] tracking-widest uppercase font-bold">End of Transmission</span>
                            </div>
                        </div>
                    </motion.div>
                    <motion.p initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ delay: 2 }} className="absolute bottom-12 text-xs font-serif text-ink/40 tracking-widest pointer-events-none">拖拽纸条 · 点击 × 收入口袋</motion.p>
                </div>
            );
        };

        const App = () => {
            const [screen, setScreen] = useState(ScreenState.COURTYARD);
            const [stones, setStones] = useState([]);
            const [gardenItems, setGardenItems] = useState([]);
            const [currentShape, setCurrentShape] = useState(generateOrganicShape());
            const [currentWorry, setCurrentWorry] = useState('');
            const [currentWeather, setCurrentWeather] = useState(Weather.SUN);
            const [currentInsight, setCurrentInsight] = useState('');

            const handleStart = (weather) => {
                setCurrentWeather(weather);
                setCurrentShape(generateOrganicShape());
                setScreen(ScreenState.ETCHING);
            };

            const handleLayDown = useCallback(async (text) => {
                setCurrentWorry(text);
                setScreen(ScreenState.OVERGROWTH);
                try {
                    const insight = await generateInsight(text, currentWeather);
                    setCurrentInsight(insight);
                } catch (e) {
                    setCurrentInsight("风吹过青苔的声音。");
                }
            }, [currentWeather]);

            const handleGrowthComplete = () => {
                setScreen(ScreenState.ECHO);
            };

            const handleReturn = () => {
                const newStone = {
                    id: Date.now().toString(),
                    worry: currentWorry,
                    insight: currentInsight,
                    timestamp: Date.now(),
                    weather: currentWeather,
                    shapePolygon: currentShape,
                    rotation: Math.random() * 30 - 15,
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 200 - 100
                };
                setStones(prevStones => [...prevStones, newStone]);
                setScreen(ScreenState.COURTYARD);
                setCurrentWorry('');
                setCurrentInsight('');
            };

            const handleTransformStones = (targetStoneIds) => {
                if (!targetStoneIds || targetStoneIds.length < 9) return;
                const types = ['Lantern', 'Pine', 'Bamboo'];
                const randomType = types[Math.floor(Math.random() * types.length)];
                
                const aestheticZones = [
                    { name: '左上角', xRange: [5, 20],  yRange: [10, 25] }, 
                    { name: '右上角', xRange: [80, 95], yRange: [10, 25] }, 
                    { name: '左下角', xRange: [5, 25],  yRange: [70, 85] }, 
                    { name: '右下角', xRange: [75, 95], yRange: [70, 85] }, 
                    { name: '左边缘', xRange: [2, 12],  yRange: [35, 65] }, 
                    { name: '右边缘', xRange: [88, 98], yRange: [35, 65] }, 
                ];
                const zone = aestheticZones[Math.floor(Math.random() * aestheticZones.length)];
                const finalX = zone.xRange[0] + Math.random() * (zone.xRange[1] - zone.xRange[0]);
                const finalY = zone.yRange[0] + Math.random() * (zone.yRange[1] - zone.yRange[0]);

                const newItem = {
                    id: Date.now(),
                    type: randomType,
                    x: finalX,
                    y: finalY,
                    scale: 0.9 + Math.random() * 0.5 
                };

                setGardenItems(prev => [...prev, newItem]);
                setStones(prev => prev.filter(s => !targetStoneIds.includes(s.id)));
                
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                playSound('lift'); 
            };

            return (
                <main className="w-full h-screen overflow-hidden bg-concrete text-ink font-sans selection:bg-moss selection:text-white relative">
                    <AnimatePresence mode="wait">
                        {screen === ScreenState.COURTYARD && (
                            <motion.div key="courtyard" className="w-full h-full" exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Courtyard stones={stones} onStart={handleStart} onUpdateStones={setStones} gardenItems={gardenItems} onTransform={handleTransformStones} />
                            </motion.div>
                        )}
                        {screen === ScreenState.ETCHING && (
                            <motion.div key="etching" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Etching stoneShape={currentShape} onLayDown={handleLayDown} />
                            </motion.div>
                        )}
                        {screen === ScreenState.OVERGROWTH && (
                            <motion.div key="overgrowth" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.8 } }}>
                                <Overgrowth worry={currentWorry} stoneShape={currentShape} onGrowthComplete={handleGrowthComplete} />
                            </motion.div>
                        )}
                        {screen === ScreenState.ECHO && (
                            <motion.div key="echo" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Echo insight={currentInsight} stoneShape={currentShape} onReturn={handleReturn} />
                            </motion.div>
                        )}
                    </AnimatePresence>
                </main>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
