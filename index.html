<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Moss & Stone</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              concrete: '#E0E0E0',
              'concrete-dark': '#C0C0C0',
              moss: '#3A4D1F',
              'moss-light': '#7B924A',
              ink: '#2C2C2C',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              serif: ['"Noto Serif SC"', 'serif'],
            },
          },
        },
      }
    </script>

    <style>
      body {
        background-color: #E0E0E0;
        color: #2C2C2C;
        overflow: hidden; /* 防止 Body 滚动，交由内部容器滚动 */
        touch-action: none;
      }
      
      .noise-bg {
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        pointer-events: none; z-index: 50; opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      .carved-deep {
        color: rgba(44, 44, 44, 0.65) !important;
        text-shadow: 
            0px 1px 0px rgba(255,255,255, 0.6), 
            0px -1px 1px rgba(0,0,0, 0.2) !important;
        transition: all 1s ease-out;
      }

      textarea:focus, input:focus {
        outline: none !important;
        box-shadow: none !important;
        border: none !important;
      }
      
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { 
          -ms-overflow-style: none;
          scrollbar-width: none;
      }

     .jagged-top {
          /* 【细腻撕痕 - 顶部】
             1. viewBox='0 0 12 6'：把画布缩小，细节更丰富。
             2. points：不再是直线，而是高低起伏的随机坐标 (2,0, 4,3, 6,1...)。
             3. 左右延伸 (-1 和 13)：依然保留重叠逻辑，防止竖线缝隙。
          */
          background-image: url("data:image/svg+xml,%3Csvg width='12' height='6' viewBox='0 0 12 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='-1,6 0,4 2,1 4,4 6,2 8,5 10,1 12,4 13,6' fill='%23Fdfdfd'/%3E%3C/svg%3E");
          
          background-position: bottom left;
          /* 尺寸缩小到 12px 宽，让撕痕看起来非常致密、细腻 */
          background-size: 12px 6px; 
          background-repeat: repeat-x;
          width: 100%;
          height: 6px; /* 高度也相应减小 */
      }

      .jagged-bottom {
          /* 【细腻撕痕 - 底部】
             逻辑同上，方向相反。
          */
          background-image: url("data:image/svg+xml,%3Csvg width='12' height='6' viewBox='0 0 12 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='-1,0 0,2 2,5 4,2 6,4 8,1 10,5 12,2 13,0' fill='%23Fdfdfd'/%3E%3C/svg%3E");
          
          background-position: top left;
          background-size: 12px 6px;
          background-repeat: repeat-x;
          width: 100%;
          height: 6px;
      }
      
      .drop-shadow-jagged {
          filter: drop-shadow(4px 4px 10px rgba(0,0,0,0.15));
      }

      /* 庭院滚动容器样式 */
      .courtyard-scroll-container {
          height: 100vh;
          overflow-y: auto;
          scroll-snap-type: y mandatory;
          scroll-behavior: smooth;
      }
      
      .courtyard-page {
          height: 100vh;
          width: 100%;
          scroll-snap-align: start;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden; /* 限制石头拖拽不出界 */
      }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="noise-bg"></div>
    
    <svg style="display: none;">
        <defs>
            <filter id="mossRoughness">
                <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch" />
                <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 1.2 -0.2" />
            </filter>
            <filter id="mossFuzz">
                <feTurbulence type="fractalNoise" baseFrequency="2.5" numOctaves="3" stitchTiles="stitch" />
                <feContrast in="SourceGraphic" mode="linear" slope="2" />
            </filter>
        </defs>
    </svg>

    <script type="text/babel">
        // ==========================================
        // 0. 配置区域
        // ==========================================
        const INSIGHT_DICT = {
            // 【万能/通用】(以“自然规律”为主，回应所有困惑)
            universal: [
                "石头从不着急赶路。",
                "青苔不懂石头的坚硬，但它懂得拥抱。",
                "山谷没有回音，是因为它在倾听。",
                "有些重量，放下后才能看清形状。",
                "风吹过，痕迹变淡，但石头记得。",
                "此刻的粗糙，是未来圆润的开始。",
                "河流流过，不留痕迹。",
                "看不见的根，比看得见的叶更深。",
                "世界是空旷的，回音全来自自身。",
                "不要慌张，月亮也经常失眠。"
            ],
            // 【抚慰/治愈】(对应雨天/疲惫 -> 青苔的柔软)
            comfort: [
                "青苔只在阴影里生长，不必时刻向阳。",
                "雨水归于大海，情绪也终将平静。",
                "允许自己像石头一样，在这个午后静止。",
                "裂缝不是破碎，是光和苔藓的入口。",
                "落叶归根，并不是某种失败。",
                "哪怕是石头，淋雨久了也会变软。",
                "躲在壳里也没关系，蜗牛也是这样长大的。",
                "潮湿的时候，就长一点青苔吧。",
                "不必坚强，像水一样流淌就好。",
                "夜色落下，一切都会变得温柔。"
            ],
            // 【勇气/行动】(对应晴天/迷茫 -> 石头的坚定)
            courage: [
                "山不向我走来，我便站住。",
                "悬崖不害怕坠落，它成为了风景。",
                "急流中，只有最重的石头最安静。",
                "风无法撼动扎根的树。",
                "把心变成石头，就不怕硬碰硬。",
                "路没有尽头，只有路口。",
                "去撞击吧，像浪花撞击礁石那样。",
                "所有的墙，最后都会变成门。",
                "野草不需要园丁的允许也能生长。",
                "站直了，影子自然会跟随你。"
            ],
            // 【等待/释怀】(对应多云/纠结 -> 时间的流逝)
            patience: [
                "花只开一次，但年年准时。",
                "等待也是一种生长，像钟乳石那样。",
                "时间是风，记忆是灰，让它散去。",
                "冬天来了，春天就不会迷路。",
                "旧物比新人更懂沉默。",
                "如果水流不通，那就变成湖泊。",
                "答案像雾，太阳出来就会显现。",
                "不要追赶落日，它明天还会升起。",
                "缘起缘灭，像云聚云散。",
                "有些事，过了一个季节就懂了。"
            ]
        };

// ==========================================
// 替换后的生成式音效系统 (不需要 mp3 文件)
// ==========================================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// 生成白噪声缓存
const bufferSize = audioCtx.sampleRate * 2; 
const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
const output = noiseBuffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
}

const playSound = (type, volume = 1.0) => {
    const runAudioLogic = () => {
        const t = audioCtx.currentTime;
        const gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);

        if (type === 'lift') {
            // --- 抬起 ---
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;
            source.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(150, t);
            
            source.connect(filter);
            filter.connect(gainNode);
            
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.1, t + 0.1); 
            gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            
            source.start(t);
            source.stop(t + 0.35);
            
        } else if (type === 'drop') {
            // --- 放下 ---
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            
            osc.frequency.setValueAtTime(90, t);
            osc.frequency.exponentialRampToValueAtTime(30, t + 0.12);
            
            gainNode.gain.setValueAtTime(0.5, t);
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
            
            osc.connect(gainNode);
            osc.start(t);
            osc.stop(t + 0.7);

       } else if (type === 'organize') {
            // --- 整理 (保留原有代码) ---
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, t);
            
            source.connect(filter);
            filter.connect(gainNode);
            
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.1, t + 0.02); 
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6); 
            
            source.start(t);
            source.stop(t + 0.7);

        // ===============================================
        //  ▼▼▼ 这里是新加入的“凿字”音效 ▼▼▼
        // ===============================================
        } else if (type === 'carve') {
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;

            // 【修改点】使用 Lowpass (低通)，模拟沉闷的机械键盘声
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass'; 
            // 频率设为 800Hz - 1200Hz，这个范围听起来像敲击实木或厚塑料
            filter.frequency.setValueAtTime(1000, t); 
            
            source.connect(filter);
            filter.connect(gainNode);


            const peakGain = 0.6 * volume;

            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(peakGain, t + 0.005); 
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.04); 

            source.start(t);
            source.stop(t + 0.05);
        }
    };

    // 2. 检查引擎状态：
    // 如果是“挂起/休眠”状态 (suspended)，先唤醒，等唤醒成功(.then)后再发声
    if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
            runAudioLogic();
        });
    } else {
        // 如果已经是“运行中” (running)，直接发声
        runAudioLogic();
    }
};
        // ==========================================
        // 1. 工具函数
        // ==========================================
        const { motion, AnimatePresence } = window.Motion || {};
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // 【补全这个缺失的函数】
        const chunkArray = (array, size) => {
            const result = [];
            for (let i = 0; i < array.length; i += size) {
                result.push(array.slice(i, i + size));
            }
            return result;
        };

        const Icons = {
            Sun: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="5"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M4.22 4.22l1.42 1.42"/><path d="M18.36 18.36l1.42 1.42"/><path d="M1 12h2"/><path d="M21 12h2"/><path d="M4.22 19.78l1.42-1.42"/><path d="M18.36 5.64l1.42-1.42"/></svg>,
            Cloud: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>,
            CloudRain: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 13v8"/><path d="M8 13v8"/><path d="M12 15v8"/><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"/></svg>,
            CloudLightning: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 16.326A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 .5 8.973"/><path d="m13 12-3 5h4l-3 5"/></svg>,
            X: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>,
            Trash: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Grid: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
            Broom: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 2l-4 14"/><path d="M2 16h20"/><path d="M6 16v6"/><path d="M10 16v6"/><path d="M14 16v6"/><path d="M18 16v6"/></svg>
        };

// ==========================================
        // 新增素材：庭院装饰物 (水墨风格 SVG)
        // ==========================================
        const Decorations = {
            // 1. 石灯笼 (象征指引)
            Lantern: () => (
                <g opacity="0.6">
                    <path d="M40 100 L60 100 L55 80 L45 80 Z" fill="#2C2C2C" /> {/* 基座 */}
                    <path d="M48 80 L52 80 L52 60 L48 60 Z" fill="#2C2C2C" /> {/* 柱 */}
                    <path d="M35 60 L65 60 L60 40 L40 40 Z" fill="#2C2C2C" /> {/* 灯室 */}
                    <path d="M30 40 Q50 20 70 40 L30 40" fill="#2C2C2C" /> {/* 顶盖 */}
                    <circle cx="50" cy="35" r="3" fill="#E0E0E0" /> {/* 顶珠 */}
                    {/* 微光效果 */}
                    <circle cx="50" cy="50" r="8" fill="#F9A825" opacity="0.3" filter="url(#mossFuzz)" />
                </g>
            ),
            // 2. 古松 (象征坚韧)
            Pine: () => (
                <g>
                    {/* --- 树干 (浓墨，模拟粗糙树皮) --- */}
                    {/* 主干：扭曲向上，底部粗壮 */}
                    <path 
                        d="M55 145 L45 145 Q40 120 50 100 Q35 90 30 75 Q45 80 55 90 Q60 70 55 50 L60 50 Q70 80 75 100 Q65 120 55 145 Z" 
                        fill="#2C2C2C" 
                        opacity="0.9" 
                    />
                    {/* 树枝：向右延伸的侧枝 */}
                    <path d="M55 90 Q75 95 90 85" stroke="#2C2C2C" strokeWidth="3" fill="none" strokeLinecap="round" />
                    {/* 树枝：向左的小枝 */}
                    <path d="M50 100 Q35 105 20 95" stroke="#2C2C2C" strokeWidth="2.5" fill="none" strokeLinecap="round" />
                    {/* 树枝：顶端 */}
                    <path d="M55 50 Q50 35 60 20" stroke="#2C2C2C" strokeWidth="2" fill="none" strokeLinecap="round" />

                    {/* --- 松针/树冠 (利用滤镜制造毛绒感) --- */}
                    {/* 右侧主树冠 */}
                    <circle cx="90" cy="85" r="14" fill="#3A4D1F" opacity="0.8" filter="url(#mossRoughness)" />
                    <circle cx="85" cy="80" r="10" fill="#1a260e" opacity="0.5" filter="url(#mossRoughness)" /> {/* 阴影层 */}
                    
                    {/* 左侧树冠 */}
                    <circle cx="20" cy="95" r="12" fill="#3A4D1F" opacity="0.8" filter="url(#mossRoughness)" />
                    
                    {/* 顶部树冠 */}
                    <circle cx="60" cy="20" r="15" fill="#3A4D1F" opacity="0.9" filter="url(#mossRoughness)" />
                    <circle cx="50" cy="25" r="10" fill="#7B924A" opacity="0.6" filter="url(#mossRoughness)" /> {/* 高光层 */}

                    {/* 中部点缀 (增加层次) */}
                    <circle cx="50" cy="60" r="8" fill="#3A4D1F" opacity="0.7" filter="url(#mossRoughness)" />
                </g>
            ),
            // 3. 翠竹 (象征虚心)
            Bamboo: () => (
                <g>
                    {/* --- 后景竹 (淡墨，营造景深) --- */}
                    <path d="M65 145 Q70 100 68 30" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.4" strokeLinecap="round" />
                    {/* 竹节 */}
                    <path d="M66 110 L70 109" stroke="#2C2C2C" strokeWidth="1" opacity="0.3" />
                    <path d="M67 70 L71 69" stroke="#2C2C2C" strokeWidth="1" opacity="0.3" />
                    
                    {/* --- 左侧竹 (中墨) --- */}
                    <path d="M35 150 Q30 90 38 40" stroke="#3A4D1F" strokeWidth="3" fill="none" opacity="0.7" strokeLinecap="round" />
                    {/* 竹节 */}
                    <path d="M30 120 L40 118" stroke="#2C2C2C" strokeWidth="1.5" opacity="0.6" />
                    <path d="M32 80 L42 78" stroke="#2C2C2C" strokeWidth="1.5" opacity="0.6" />
                    
                    {/* --- 主竹 (浓墨，挺拔) --- */}
                    <path d="M50 155 Q52 80 48 10" stroke="#2C2C2C" strokeWidth="4" fill="none" opacity="0.85" strokeLinecap="round" />
                    {/* 竹节 (强调骨力) */}
                    <path d="M45 125 L56 123" stroke="#2C2C2C" strokeWidth="2" />
                    <path d="M46 90 L57 88" stroke="#2C2C2C" strokeWidth="2" />
                    <path d="M47 55 L58 53" stroke="#2C2C2C" strokeWidth="2" />

                    {/* --- 竹叶 (聚散有致，模拟笔触) --- */}
                    {/* 顶部竹叶组 */}
                    <path d="M48 20 L35 25 M48 20 L55 10 M48 20 L60 25" stroke="#3A4D1F" strokeWidth="2" fill="none" />
                    
                    {/* 中部竹叶组 (左) */}
                    <path d="M38 40 L25 45 M38 40 L28 30" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.8" />
                    
                    {/* 中部竹叶组 (右) */}
                    <path d="M46 90 L60 95 M46 90 L65 85" stroke="#3A4D1F" strokeWidth="2" fill="none" opacity="0.8" />
                    
                    {/* 底部竹叶组 (点缀) */}
                    <path d="M30 120 L20 125" stroke="#3A4D1F" strokeWidth="1.5" fill="none" opacity="0.6" />
                </g>
            )
        };

        const ScreenState = {
            COURTYARD: 'COURTYARD',
            ETCHING: 'ETCHING',
            OVERGROWTH: 'OVERGROWTH',
            ECHO: 'ECHO'
        };

        const Weather = {
            SUN: 'Sun',
            CLOUD: 'Cloud',
            RAIN: 'Rain',
            STORM: 'Storm'
        };

        const generateOrganicShape = () => {
            const r = () => 30 + Math.random() * 40; 
            return `${r()}% ${r()}% ${r()}% ${r()}% / ${r()}% ${r()}% ${r()}% ${r()}%`;
        };

        const generateInsight = async (text, weatherType) => {
            return new Promise(resolve => {
                // 模拟思考时间 (保留神秘感)
                const thinkTime = 1500 + Math.random() * 1200;
                
                setTimeout(() => {
                    const t = (text || "").toLowerCase();
                    
                    // ==========================================
                    // 1. 【黑科技】命运哈希 (Destiny Hash)
                    // 将用户的输入转化成一个唯一的数字种子
                    // 同样的输入 = 同样的回答 (增加宿命感)
                    // ==========================================
                    let hash = 0;
                    for (let i = 0; i < t.length; i++) {
                        const char = t.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // Convert to 32bit integer
                    }
                    const seed = Math.abs(hash); // 得到一个正整数指纹

                    // ==========================================
                    // 2. 维度定义 (情绪 + 话题)
                    // ==========================================
                    const dict = {
                        // 否定词 (避免"我不难过"被识别为难过)
                        negations: ["不", "没", "非", "别", "无", "not", "no", "don't"],
                        
                        // 情绪维度
                        emotions: {
                            negative: ["累", "痛", "苦", "哭", "烦", "死", "糟", "烂", "丧", "病", "难", "累", "倦", "sad", "bad", "tired"],
                            fear: ["怕", "慌", "恐", "吓", "避", "逃", "不敢", "担心", "afraid", "fear"],
                            confused: ["迷", "惑", "乱", "晕", "不懂", "不知", "怀疑", "lost", "confused"]
                        },
                        
                        // 话题维度
                        topics: {
                            love: ["爱", "情", "他", "她", "你", "想", "念", "分", "离", "前任", "友", "家", "love", "miss"],
                            work: ["职", "工", "作", "钱", "穷", "忙", "业", "考", "学", "板", "户", "work", "job", "money"],
                            self: ["我", "己", "人", "命", "运", "性格", "自", "self", "life"]
                        }
                    };

                    // ==========================================
                    // 3. 语义交叉分析 (Intersection Analysis)
                    // ==========================================
                    
                    // 辅助函数：检测是否包含，且排除否定词干扰
                    // 比如 "不难过" -> 返回 false
                    const has = (keywords) => {
                        return keywords.some(k => {
                            const idx = t.indexOf(k);
                            if (idx === -1) return false;
                            // 简单的否定检测：看关键词前面2个字有没有否定词
                            const prev2Chars = t.substring(Math.max(0, idx - 2), idx);
                            const isNegated = dict.negations.some(n => prev2Chars.includes(n));
                            return !isNegated; 
                        });
                    };

                    let category = null;

                    // --- 场景 A: 职业倦怠 (工作 + 负面/累) ---
                    if (has(dict.topics.work) && (has(dict.emotions.negative) || has(dict.emotions.fear))) {
                        // 针对工作的累，给 "Comfort" (休息) 或 "Courage" (坚持)
                        // 用 hash 决定给哪种，给用户惊喜
                        category = (seed % 2 === 0) ? "comfort" : "courage";
                    }
                    
                    // --- 场景 B: 情感困局 (爱 + 负面/迷茫) ---
                    else if (has(dict.topics.love) && (has(dict.emotions.negative) || has(dict.emotions.confused))) {
                        // 感情问题，通常需要 "Patience" (释怀/等待)
                        category = "patience";
                    }

                    // --- 场景 C: 自我内耗 (我 + 怕/迷茫) ---
                    else if (has(dict.topics.self) && has(dict.emotions.confused)) {
                        // 找自己，需要 "Courage" (勇气/方向)
                        category = "courage";
                    }

                    // --- 场景 D: 纯粹的情绪宣泄 ---
                    else if (has(dict.emotions.negative)) category = "comfort"; // 纯难过 -> 抚慰
                    else if (has(dict.emotions.fear)) category = "courage";     // 纯害怕 -> 鼓励
                    else if (has(dict.emotions.confused)) category = "patience";// 纯迷茫 -> 等待

                    // --- 场景 E: 兜底逻辑 (天气 + 随机) ---
                    else {
                        // 如果什么都没命中，根据天气定大方向
                        if (weatherType === 'Rain') category = "comfort";
                        else if (weatherType === 'Cloud') category = "patience";
                        else category = "universal";
                    }

                    // ==========================================
                    // 4. 最终抽取 (混合了宿命感与随机性)
                    // ==========================================
                    
                    // 获取目标池
                    // 如果命中了特定类别，我们把那个类别加倍，增加权重，同时也混入 Universal 增加禅意
                    let pool = [...INSIGHT_DICT[category || "universal"]];
                    
                    // 如果分类明确，额外混入几句 Universal 作为调味（避免太像人工客服）
                    if (category && category !== "universal") {
                        pool = [...pool, ...INSIGHT_DICT.universal];
                    }

                    // 【核心修改】
                    // 这里不再使用纯 Math.random()。
                    // 而是使用 (seed + 当天日期) 来做随机。
                    // 这样：同1小时内，你输入同样的话，得到的回答是一样的（宿命感）。
                    // 1小时后再输，会变（时间流动感）。
                    
                    const daySeed = new Date().getDate() + new Date().getHours();
                    const finalIndex = (seed + daySeed) % pool.length;
                    
                    resolve(pool[finalIndex]);

                }, thinkTime);
            });
        };

        // ==========================================
        // 2. 基础组件 Stone (已修复输入框点击问题)
        // ==========================================
        const Stone = ({ shape, size = 'md', isMossy = false, className = '', onClick, children, style }) => {
            const sizeClasses = {
                sm: 'w-16 h-16',
                md: 'w-32 h-32',
                lg: 'w-80 h-80' 
            };
            
            const thickShadowStyle = `
                inset 2px 2px 10px rgba(255,255,255, 0.8), 
                inset -3px -3px 15px rgba(0,0,0, 0.25), 
                0px 5px 5px rgba(0,0,0, 0.15), 
                0px 12px 20px rgba(0,0,0, 0.1), 
                0px 25px 40px rgba(0,0,0, 0.1)
            `;

            return (
                <div 
                    onClick={onClick}
                    className={`relative bg-[#d4d4d4] overflow-hidden cursor-grab active:cursor-grabbing transition-all duration-300 ease-out ${sizeClasses[size]} ${className}`}
                    style={{ 
                        borderRadius: shape,
                        boxShadow: thickShadowStyle,
                        transform: 'translateZ(0) perspective(500px) rotateX(2deg)',
                        backfaceVisibility: 'hidden',
                        ...style
                    }}
                >
                    <div className="absolute inset-0 opacity-20 pointer-events-none z-0" 
                         style={{
                             backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`
                         }}
                    ></div>

                    {isMossy && (
                        <>
                            <div className="absolute inset-0 z-10 opacity-70 mix-blend-multiply pointer-events-none"
                                 style={{
                                    backgroundColor: '#4A5D23',
                                    filter: 'url(#mossRoughness) contrast(1.2)',
                                    transform: 'scale(1.02)'
                                 }}
                            ></div>
                            <div className="absolute inset-0 z-10 opacity-60 mix-blend-overlay pointer-events-none"
                                 style={{
                                     backgroundColor: '#8A9A5B',
                                     backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")`,
                                     boxShadow: 'inset 5px 5px 20px rgba(255,255,255,0.3)'
                                 }}
                            ></div>
                             <div className="absolute inset-0 z-10 pointer-events-none opacity-40 mix-blend-multiply"
                                 style={{
                                     background: 'radial-gradient(circle at 30% 30%, transparent 40%, #1a260e 100%)'
                                 }}
                            ></div>
                        </>
                    )}

                    {/* 【关键修改】这里去掉了 pointer-events-none 
                        保证输入框（textarea）可以被点击聚焦
                    */}
                    <div className="relative z-20 w-full h-full">
                        {children}
                    </div>
                </div>
            );
        };

        // ==========================================
        // 3. 核心页面组件
        // ==========================================

// --- Courtyard (庭院 - 无限分页 + 自动滚动版) ---
const Courtyard = ({ stones, onStart, onUpdateStones, gardenItems, onTransform }) => {
    // ==========================================
    // 1. 逻辑与状态定义区
    // ==========================================
    
    const [windowSize, setWindowSize] = useState({ w: window.innerWidth, h: window.innerHeight });

    useEffect(() => {
        const handleResize = () => setWindowSize({ w: window.innerWidth, h: window.innerHeight });
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    const xLimit = windowSize.w / 2 - 60;
    const yLimit = windowSize.h / 2 - 90;

    const [isSelectorOpen, setIsSelectorOpen] = useState(false);
    const [selectedStone, setSelectedStone] = useState(null);
    const [currentPageIndex, setCurrentPageIndex] = useState(0);
    const [showClearConfirm, setShowClearConfirm] = useState(false);
    const [showTransformConfirm, setShowTransformConfirm] = useState(false);
    const [showNotReadyTip, setShowNotReadyTip] = useState(false);

    const isDraggingRef = useRef(false);
    const scrollContainerRef = useRef(null);
    const pageRefs = useRef([]);

    const stoneChunks = useMemo(() => {
        const sorted = [...stones]; 
        const chunks = chunkArray(sorted, 9);
        if (chunks.length === 0) chunks.push([]);
        while (chunks.length <= currentPageIndex) {
            chunks.push([]);
        }
        return chunks;
    }, [stones, currentPageIndex]);

    // 【新增】获取当前页面显示的石头列表 (这就是“眼前”的石头)
    const currentChunk = stoneChunks[currentPageIndex] || [];

    const smoothScrollTo = (element, target, duration) => {
        const start = element.scrollTop;
        const change = target - start;
        const startTime = performance.now();
        element.style.scrollSnapType = 'none';
        const animateScroll = (currentTime) => {
            const timeElapsed = currentTime - startTime;
            if (timeElapsed < duration) {
                const progress = timeElapsed / duration;
                const ease = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                element.scrollTop = start + (change * ease);
                requestAnimationFrame(animateScroll);
            } else {
                element.scrollTop = target;
                element.style.scrollSnapType = 'y mandatory';
            }
        };
        requestAnimationFrame(animateScroll);
    };

    useEffect(() => {
        if (stoneChunks.length > 1) {
            const lastPageIndex = stoneChunks.length - 1;
            const container = scrollContainerRef.current;
            if (container) {
                const pageHeight = container.clientHeight;
                const targetScrollTop = lastPageIndex * pageHeight;
                const prevPageScrollTop = (lastPageIndex - 1) * pageHeight;
                container.style.scrollBehavior = 'auto'; 
                if (container.scrollTop < 10) container.scrollTop = prevPageScrollTop;
                smoothScrollTo(container, targetScrollTop, 1500); 
            }
        }
    }, [stones.length, stoneChunks.length]);

    const weatherOptions = [
        { type: Weather.SUN, icon: Icons.Sun, label: "晴朗" },
        { type: Weather.CLOUD, icon: Icons.Cloud, label: "多云" },
        { type: Weather.RAIN, icon: Icons.CloudRain, label: "雨天" },
        { type: Weather.STORM, icon: Icons.CloudLightning, label: "风暴" },
    ];

    const formatDate = (timestamp) => {
        const date = new Date(timestamp);
        const Y = date.getFullYear();
        const M = (date.getMonth() + 1).toString().padStart(2, '0');
        const D = date.getDate().toString().padStart(2, '0');
        const h = date.getHours().toString().padStart(2, '0');
        const m = date.getMinutes().toString().padStart(2, '0');
        return `${Y}年${M}月${D}日 ${h}:${m}`;
    };

    const handleScroll = () => {
        if (!scrollContainerRef.current) return;
        const scrollTop = scrollContainerRef.current.scrollTop;
        const height = scrollContainerRef.current.clientHeight;
        const index = Math.round(scrollTop / height);
        setCurrentPageIndex(index);
    };

    const handleDragEnd = (stoneId, info) => {
        const delta = { x: info.offset.x, y: info.offset.y };
        onUpdateStones(prev => prev.map(s => {
            if (s.id === stoneId) {
                let newX = (s.x || 0) + delta.x;
                let newY = (s.y || 0) + delta.y;
                newX = Math.max(-xLimit, Math.min(newX, xLimit));
                newY = Math.max(-yLimit, Math.min(newY, yLimit));
                return { ...s, x: newX, y: newY };
            }
            return s;
        }));
    };

    const handleOrganize = () => {
        playSound('organize');
        if(currentChunk.length === 0) return;
        const gridGap = 110; 
        const startX = -110; 
        const startY = -120; 
        const updates = {};
        currentChunk.forEach((stone, index) => {
            const row = Math.floor(index / 3);
            const col = index % 3;
            updates[stone.id] = { x: startX + col * gridGap, y: startY + row * gridGap, rotation: 0 };
        });
        onUpdateStones(prev => prev.map(s => updates[s.id] ? { ...s, ...updates[s.id] } : s));
    };

    const handleClear = (type) => {
        if (type === 'current') {
            const stonesToRemove = currentChunk.map(s => s.id);
            onUpdateStones(prev => prev.filter(s => !stonesToRemove.includes(s.id)));
        } else if (type === 'all') {
            onUpdateStones([]);
        }
        setShowClearConfirm(false);
    };

    // 【智能转化点击逻辑】
    // 依赖于 currentChunk.length 而不是 stones.length
    const handleTransformationClick = () => {
        if (currentChunk.length >= 9) {
            setShowTransformConfirm(true);
        } else {
            setShowNotReadyTip(true);
            setTimeout(() => setShowNotReadyTip(false), 2000);
        }
    };

    const getPageDateRange = (chunk) => {
        if (!chunk || chunk.length === 0) return "";
        const fmt = (ts) => {
            const d = new Date(ts);
            return `${d.getFullYear()}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`;
        };
        const startStr = fmt(chunk[0].timestamp);
        const endStr = fmt(chunk[chunk.length - 1].timestamp);
        return startStr === endStr ? startStr : `${startStr} - ${endStr}`;
    };

    // ==========================================
    // 2. 视图渲染区
    // ==========================================
    return (
        <div className="relative w-full h-full">
            <header className="absolute top-4 left-0 w-full text-center z-20 pointer-events-none">
                <h1 className="text-3xl font-serif font-bold text-ink opacity-80">苔与石</h1>
                <p className="text-xs text-ink/60 mt-2 tracking-[0.2em] uppercase">Moss & Stone</p>
                
                {/* 左上角计数器：显示当前页进度，更直观 */}
                {stones.length > 0 && (
                    <div className="absolute top-2 right-[-60px] md:right-[-100px] text-[10px] text-ink/20 font-sans">
                        本页: {currentChunk.length}/9
                    </div>
                )}
            </header>

           {/* 庭院景观层 */}
            {/* 【修复点 1】去掉 pointer-events-none，否则鼠标点不到
                改成 pointer-events-auto 或者直接删掉这一行
            */}
            <div className="absolute inset-0 z-0 overflow-hidden pointer-events-auto"> 
                {gardenItems && gardenItems.map(item => {
                    const Component = Decorations[item.type];
                    return (
                        <motion.div
                            key={item.id}
                            
                            /* 【修复点 2】加上 drag 属性，开启拖拽 */
                            drag 
                            
                            /* 【修复点 3】dragMomentum={false} 
                               让它像搬家具一样，松手即停，而不是像冰块一样滑走 
                            */
                            dragMomentum={false} 

                            initial={{ opacity: 0, scale: 0 }}
                            animate={{ opacity: 1, scale: item.scale }}
                            transition={{ duration: 2, ease: "easeOut" }}
                            
                            /* 【修复点 4】加上 cursor-move 提示用户可以拖 */
                            className="absolute cursor-move" 
                            
                            style={{
                                left: `${item.x}%`,
                                top: `${item.y}%`,
                                filter: 'blur(1px) drop-shadow(0 4px 6px rgba(0,0,0,0.1))'
                            }}
                        >
                            <svg width="100" height="150" viewBox="0 0 100 150">
                                <Component />
                            </svg>
                        </motion.div>
                    );
                })}
            </div>

            {/* 调试按钮 (+1 石头) */}
            {/* ================= 调试用按钮 START (发布前删除) ================= */}
            <button
                onClick={() => {
                    const newStone = {
                        id: `debug-${Date.now()}`,
                        worry: `测试数据 ${stones.length + 1}`,
                        insight: `测试数据：青苔不懂石头的坚硬。`,
                        timestamp: Date.now(),
                        weather: 'Sun',
                        shapePolygon: generateOrganicShape(), 
                        rotation: Math.random() * 30 - 15,
                        x: Math.random() * 160 - 80, 
                        y: Math.random() * 160 - 80
                    };
                    onUpdateStones(prev => [...prev, newStone]);
                }}
                className="absolute bottom-4 right-4 z-50 px-4 py-2 bg-red-500/10 border border-red-500/30 text-red-800/60 text-xs font-bold rounded hover:bg-red-500/20 transition-colors backdrop-blur-md"
            >
                [测试] +1
            </button>
            {/* ================= 调试用按钮 END ================= */}

            {/* 右上角工具栏 */}
            {stones.length > 0 && (
                <div className="absolute top-6 right-6 z-30 flex flex-col gap-4 items-center">
                    <button onClick={handleOrganize} className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-moss transition-all shadow-sm backdrop-blur-sm" title="整理">
                        <Icons.Grid size={20} />
                    </button>
                    
                    <button onClick={() => setShowClearConfirm(true)} className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-red-800 transition-all shadow-sm backdrop-blur-sm" title="清扫">
                        <Icons.Broom size={20} />
                    </button>

                    {/* 【智能转化按钮】
                        逻辑修改：currentChunk.length >= 8 时才出现
                    */}
                    <AnimatePresence>
                        {currentChunk.length >= 8 && (
                            <div className="relative">
                                <motion.button
                                    initial={{ scale: 0, opacity: 0 }}
                                    animate={{ 
                                        scale: 1, 
                                        opacity: 1,
                                        // 仅当本页满9个时，才呼吸发光
                                        boxShadow: currentChunk.length >= 9 
                                            ? "0 0 15px rgba(58, 77, 31, 0.5), inset 0 0 10px rgba(255,255,255,0.3)" 
                                            : "none"
                                    }}
                                    exit={{ scale: 0, opacity: 0 }} 
                                    transition={{ type: "spring", stiffness: 300, damping: 20 }}
                                    whileHover={{ scale: 1.1 }}
                                    whileTap={{ scale: 0.9 }}
                                    onClick={handleTransformationClick}
                                    className={`
                                        w-10 h-10 rounded-full flex items-center justify-center 
                                        backdrop-blur-md border border-white/30 shadow-lg
                                        transition-all duration-500
                                        ${currentChunk.length >= 9 
                                            ? "bg-moss text-white/90 animate-pulse" 
                                            : "bg-moss/20 text-moss/50" 
                                        }
                                    `}
                                >
                                    <span className="text-sm">⭕</span>
                                </motion.button>

                                <AnimatePresence>
                                    {showNotReadyTip && (
                                        <motion.div
                                            initial={{ opacity: 0, x: -10 }}
                                            animate={{ opacity: 1, x: -50 }}
                                            exit={{ opacity: 0 }}
                                            className="absolute top-1/2 -translate-y-1/2 right-0 whitespace-nowrap pointer-events-none"
                                        >
                                            <div className="bg-ink/80 text-white text-[10px] px-2 py-1 rounded-md shadow-sm font-serif">
                                                还剩 {9 - currentChunk.length} 个苔石解锁
                                            </div>
                                        </motion.div>
                                    )}
                                </AnimatePresence>
                            </div>
                        )}
                    </AnimatePresence>
                </div>
            )}

            <div ref={scrollContainerRef} onScroll={handleScroll} className="courtyard-scroll-container no-scrollbar">
                {stoneChunks.map((chunk, pageIndex) => (
                    <div key={pageIndex} ref={el => pageRefs.current[pageIndex] = el} className="courtyard-page">
                        <div className="relative w-[340px] h-[340px] md:w-[500px] md:h-[500px]">
                            <AnimatePresence>
                                {chunk.map((stone, i) => (
                                    <motion.div 
                                        key={stone.id} 
                                        drag
                                        whileDrag={{ scale: 1.05 }} 
                                        dragMomentum={false}
                                        dragElastic={0}
                                        onPointerDown={() => { if (audioCtx.state === 'suspended') audioCtx.resume(); }}
                                        onDragStart={() => { isDraggingRef.current = true; playSound('lift'); }}
                                        onDragEnd={(e, info) => { handleDragEnd(stone.id, info); playSound('drop'); setTimeout(() => isDraggingRef.current = false, 200); }}
                                        onClick={(e) => {
                                            if (isDraggingRef.current) { e.stopPropagation(); return; }
                                            if (!isSelectorOpen && !selectedStone) setSelectedStone(stone);
                                        }}
                                        transition={{ type: "spring", stiffness: 400, damping: 25 }}
                                        dragConstraints={{ left: -xLimit, right: xLimit, top: -yLimit, bottom: yLimit }}
                                        initial={{ scale: 0 }}
                                        animate={{ scale: 1, x: stone.x || 0, y: stone.y || 0, rotate: stone.rotation, opacity: 1, filter: 'blur(0px)' }}
                                        exit={{ opacity: 0, scale: 0.9, y: (stone.y || 0) + 120, filter: 'blur(10px)', transition: { duration: 1.5, ease: "easeInOut", delay: i * 0.08 } }}
                                        className="absolute left-1/2 top-1/2 -ml-8 -mt-8"
                                        style={{ zIndex: 10 }}
                                    >
                                        <Stone shape={stone.shapePolygon} isMossy size="sm" className="hover:scale-105 transition-transform duration-300 shadow-lg" />
                                    </motion.div>
                                ))}
                            </AnimatePresence>

                            {/* +号按钮 */}
                            {pageIndex === stoneChunks.length - 1 && !isSelectorOpen && !selectedStone && (
                                <div className="absolute inset-0 flex items-center justify-center pointer-events-none translate-y-64">
                                    <motion.button
                                        initial={{ opacity: 0, scale: 0.9 }}
                                        animate={{ opacity: 1, scale: 1 }}
                                        whileHover={{ scale: 1.02, rotate: 2 }}
                                        whileTap={{ scale: 0.98 }}
                                        onClick={() => setIsSelectorOpen(true)}
                                        className="w-48 h-32 border-4 border-dashed border-ink/10 rounded-[40%_60%_50%_50%/50%_40%_60%_50%] flex items-center justify-center hover:border-ink/30 transition-colors bg-concrete/20 pointer-events-auto"
                                    >
                                        <span className="text-2xl text-ink/20">+</span>
                                    </motion.button>
                                </div>
                            )}
                        </div>

                        {/* 页脚信息 */}
                        <div className="absolute bottom-8 left-0 w-full text-center pointer-events-none">
                            <p className="text-[10px] font-sans font-bold tracking-[0.15em] text-ink/20 mb-1.5 uppercase">{getPageDateRange(chunk)}</p>
                            <p className="text-xs text-ink/30 font-serif tracking-widest">{pageIndex === stoneChunks.length - 1 ? "把心事，放在这里。" : "往事已生青苔。" }</p>
                            {/* 分页指示器 */}
                            {stoneChunks.length > 1 && (
                                <div className="mt-2 flex justify-center gap-1">
                                    {stoneChunks.map((_, i) => (
                                        <div key={i} className={`w-1.5 h-1.5 rounded-full ${i === currentPageIndex ? 'bg-moss' : 'bg-ink/10'}`} />
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                ))}
            </div>

            <AnimatePresence>
                {/* 弹窗部分... (保持不变，省略以节省空间，直接用原有的即可) */}
                {/* 请确保这里的 isSelectorOpen, selectedStone, showClearConfirm 弹窗代码都在 */}
                
                {/* 这里仅展示被修改了逻辑的 转化弹窗 */}
                {showTransformConfirm && (
                    <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/20 backdrop-blur-sm" onClick={() => setShowTransformConfirm(false)}>
                        <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F4F4F4] p-8 rounded-2xl shadow-2xl w-80 text-center border-2 border-moss/10">
                            <div className="mb-6 text-4xl opacity-80">⭕</div>
                            <h4 className="text-moss font-serif font-bold text-lg mb-2">庭院仪式</h4>
                            <p className="text-xs text-ink/60 mb-8 font-serif leading-relaxed">
                                此庭院承载了 9 份宝贵记忆。<br/>
                                愿意将它们化作<br/>
                                庭院里永恒的风景吗？
                            </p>
                            <button 
                                onClick={() => { 
                                    // 【核心修改】点击确认时，把当前页的石头ID列表传出去
                                    onTransform(currentChunk.map(s => s.id)); 
                                    setShowTransformConfirm(false); 
                                }} 
                                className="w-full py-3 rounded-lg bg-moss text-white text-sm tracking-widest hover:bg-moss-light transition-all shadow-lg mb-3"
                            >
                                放下，并转化
                            </button>
                            <button onClick={() => setShowTransformConfirm(false)} className="text-xs text-ink/30 hover:text-ink/60 transition-colors">我还想留着~</button>
                        </motion.div>
                    </div>
                )}
            </AnimatePresence>
            
            {/* 别忘了把其他弹窗代码也放回来，如果这里被截断了 */}
            <AnimatePresence>
                {isSelectorOpen && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm">
                        <motion.div initial={{ y: 50, opacity: 0 }} animate={{ y: 0, opacity: 1 }} exit={{ y: 50, opacity: 0 }} className="bg-[#E8E8E8] p-8 rounded-3xl shadow-2xl w-80 max-w-sm border border-white/40">
                            <h3 className="text-center text-ink/70 mb-8 font-serif text-lg">此刻内心的天气？</h3>
                            <div className="flex justify-between px-2 mb-4">
                                {weatherOptions.map((option) => (
                                    <button key={option.type} onClick={() => { setIsSelectorOpen(false); onStart(option.type); }} className="flex flex-col items-center gap-3 text-ink/40 hover:text-moss transition-colors group">
                                        <div className="p-3 rounded-full bg-white/50 group-hover:bg-white transition-colors shadow-sm"><option.icon size={24} /></div>
                                        <span className="text-xs font-serif">{option.label}</span>
                                    </button>
                                ))}
                            </div>
                            <button onClick={() => setIsSelectorOpen(false)} className="w-full mt-8 text-xs text-ink/30 tracking-widest hover:text-ink py-2">取消</button>
                        </motion.div>
                    </div>
                )}
            </AnimatePresence>
            
            <AnimatePresence>
                {selectedStone && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm" onClick={() => setSelectedStone(null)}>
                        <motion.div initial={{ scale: 0.95, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.95, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F0F0F0] p-8 rounded-2xl shadow-2xl w-80 max-w-sm border border-white/40 relative text-center m-4">
                            <button onClick={() => setSelectedStone(null)} className="absolute top-4 right-4 text-ink/30 hover:text-ink transition-colors"><Icons.X size={20} /></button>
                            <div className="mt-4 mb-8">
                                <p className="text-xs text-ink/40 font-serif tracking-widest uppercase mb-4">{formatDate(selectedStone.timestamp)}</p>
                                <div className="w-8 h-1 bg-moss/20 mx-auto mb-8 rounded-full"></div>
                                <p className="font-serif text-xl text-ink leading-loose">“{selectedStone.insight}”</p>
                            </div>
                            <div className="pt-6 border-t border-ink/5"><p className="text-xs text-moss opacity-60 font-serif tracking-widest">记忆已模糊，但智慧留存。</p></div>
                        </motion.div>
                    </div>
                )}
            </AnimatePresence>

             <AnimatePresence>
                {showClearConfirm && (
                    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/10 backdrop-blur-sm" onClick={() => setShowClearConfirm(false)}>
                        <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} onClick={(e) => e.stopPropagation()} className="bg-[#F0F0F0] p-6 rounded-2xl shadow-xl w-72 text-center border border-white/50">
                            <h4 className="text-ink/80 font-serif font-bold mb-4">清扫庭院</h4>
                            <p className="text-xs text-ink/50 mb-6 font-serif">要扫去哪些记忆？</p>
                            <div className="flex flex-col gap-3">
                                <button onClick={() => handleClear('current')} className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-ink/70 text-sm hover:bg-moss/10 hover:text-moss transition-colors">仅清扫当前页面</button>
                                <button onClick={() => handleClear('all')} className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-red-800/60 text-sm hover:bg-red-50 hover:text-red-800 transition-colors">清空所有</button>
                                <button onClick={() => setShowClearConfirm(false)} className="mt-2 text-xs text-ink/30 hover:text-ink/60 transition-colors">取消</button>
                            </div>
                        </motion.div>
                    </div>
                )}
            </AnimatePresence>
        </div>
    );
};
        // --- Etching (蚀刻) ---
        const Etching = ({ stoneShape, onLayDown }) => {
            const [text, setText] = useState('');
            const [isCarving, setIsCarving] = useState(false);
            const [carvedIndex, setCarvedIndex] = useState(0); 
            const textareaRef = useRef(null);
            const scrollRef = useRef(null);

            useEffect(() => {
                const timer = setTimeout(() => {
                    if (textareaRef.current) textareaRef.current.focus();
                }, 850);
                return () => clearTimeout(timer);
            }, []);

            useEffect(() => {
                if (isCarving && scrollRef.current) {
                    const element = scrollRef.current;
                    const isOverflowing = element.scrollHeight > element.clientHeight;
                    if (isOverflowing) {
                        element.scrollTop = element.scrollHeight;
                    }
                }
            }, [carvedIndex, isCarving]);

            useEffect(() => {
    if (!isCarving) return;

    // 结束逻辑 (保持不变，>= 逻辑正确)
    if (carvedIndex >= text.length) {
        const finishTimer = setTimeout(() => {
            onLayDown(text);
        }, 500);
        return () => clearTimeout(finishTimer);
    }

    // ==========================================
            // 1. 节奏算法：优化后的自然曲线
            // ==========================================
            let delay;
            const maxDelay = 450; // 起步的最慢速度 (毫秒)
            const minDelay = 20;  // 最快速度限制 (避免过快导致卡顿)
            
            // 【改动点1】让加速开始得更早一点点，不要等太久
            const accelerationStart = 2; 

            if (carvedIndex < accelerationStart) {
                delay = maxDelay;
            } else {
                // 计算已经加速了多少个字
                const x = carvedIndex - accelerationStart; 
                
                // 【核心改动点】将 0.5 改为 0.12
                // 0.5 = 极速陡峭加速 (断崖式)
                // 0.12 = 优雅的缓动加速 (如流水般自然变快)
                const decayFactor = 0.12; 
                
                delay = Math.max(
                    minDelay, 
                    maxDelay * Math.pow(Math.E, -decayFactor * x)
                );
                
                // 增加一点微小的随机扰动，模拟人手的“不完美感”
                const jitter = (Math.random() * 10) - 5;
                delay = Math.round(delay + jitter);
            }                        

    const timer = setTimeout(() => {
                // ==========================================
                // 【第一步】先出字
                // ==========================================
                setCarvedIndex(prev => prev + 1);

                // ==========================================
                // 【修正逻辑】安全地获取当前字符
                // ==========================================
                // 确保 carvedIndex 在 text 范围内
                const safeIndex = Math.min(carvedIndex, text.length - 1);
                const currentChar = text[safeIndex] || ""; 
                
                // 检测是否为空格、回车等不可见字符
                const isSilentChar = /\s/.test(currentChar);

                // ==========================================
                // 【第二步】精准音量控制 (查表法)
                // ==========================================
                const volumeProfile = [
                    1.00, 0.85, 0.70, 0.55, 
                    0.37, 0.28, 0.24, 0.20, 0.16, 
                    0.12, 0.10, 0.08, 0.04, 0.03, 0.01
                ];

                let currentVol = 0;
                if (carvedIndex < volumeProfile.length) {
                    currentVol = volumeProfile[carvedIndex];
                }

                // 【核心修正】
                // 1. 只有音量 > 0 才播放
                // 2. 只有不是静音字符(空格/回车) 才播放
                // 3. 额外加一个防错：确保 currentVol 是有效数字
                if (currentVol > 0 && !isSilentChar && isFinite(currentVol)) {
                    playSound('carve', currentVol); 
                }

            }, delay);

    return () => clearTimeout(timer);
}, [isCarving, carvedIndex, text, onLayDown]);

            const handleSubmit = () => {
                if (text.trim().length === 0) return;
                
                // 【关键修复】
                // 1. 立刻唤醒 AudioContext
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                // 2. 播放一个“空音效”来预热通道
                // 这能消除首字声音的延迟
                const dummyOsc = audioCtx.createOscillator();
                const dummyGain = audioCtx.createGain();
                dummyGain.gain.value = 0; // 它是静音的
                dummyOsc.connect(dummyGain);
                dummyGain.connect(audioCtx.destination);
                dummyOsc.start();
                dummyOsc.stop(0.1);

                if (textareaRef.current) textareaRef.current.blur();
                
                // 3. 稍微缩短一点等待时间 (50ms -> 10ms)，让反应更灵敏
                setTimeout(() => {
                    setIsCarving(true); 
                    setCarvedIndex(0); 
                }, 10); 
            };

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div
                        initial={{ scale: 0.9, opacity: 0 }}
                        animate={{ scale: 1, opacity: 1 }}
                        transition={{ duration: 0.8, ease: "easeOut" }}
                        className="relative"
                    >
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-20">
                                {!isCarving && (
                                    <textarea
                                        ref={textareaRef}
                                        value={text}
                                        onChange={(e) => setText(e.target.value)}
                                        placeholder="刚才发生了什么？"
                                        maxLength={130}
                                        spellCheck={false}
                                        autoComplete="off"
                                        style={{
                                            textShadow: '0px 1px 0px rgba(255,255,255,0.5)',
                                            caretColor: '#2C2C2C',
                                            outline: 'none', border: 'none', boxShadow: 'none', resize: 'none'
                                        }}
                                        className="no-scrollbar appearance-none border-0 shadow-none w-[75%] h-[55%] py-4 bg-transparent text-center text-[#333] font-serif text-lg leading-relaxed placeholder:text-ink/30 placeholder:italic placeholder:shadow-none overflow-y-auto focus:ring-0"
                                    />
                                )}
                                {isCarving && (
                                    <div 
                                        ref={scrollRef}
                                        style={{ 
                                            transform: 'translateZ(0)',
                                            maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)',
                                            WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)'
                                        }}
                                        className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-y-auto scroll-smooth"
                                    >
                                        {text.split('').map((char, index) => (
                                            <span 
                                                key={index}
                                                className={index < carvedIndex ? "carved-deep" : "opacity-0"}
                                                style={{ transition: 'opacity 0.1s' }}
                                            >
                                                {char}
                                            </span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex flex-col items-center pt-12">
                            <motion.button
                                initial={{ opacity: 0 }}
                                animate={{ opacity: text.length > 0 && !isCarving ? 1 : 0 }}
                                disabled={text.length === 0 || isCarving}
                                onClick={handleSubmit}
                                className="px-8 py-3 bg-transparent border border-ink/20 rounded-full text-ink/60 tracking-widest text-sm font-serif hover:bg-ink/5 transition-all disabled:opacity-0 focus:outline-none focus:ring-0 whitespace-nowrap"
                            >
                                {isCarving ? "刻录中..." : "刻好了，放下吧"}
                            </motion.button>
                            {!isCarving && (
                                <div className="mt-4 text-ink/20 text-xs italic font-serif">
                                    {text.length}/130
                                </div>
                            )}
                        </div>
                    </motion.div>
                </div>
            );
        };

        // --- Overgrowth (生长) ---
        const Overgrowth = ({ worry, stoneShape, onGrowthComplete }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onGrowthComplete();
                }, 5000); 
                return () => clearTimeout(timer);
            }, [onGrowthComplete]);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div className="relative">
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-0">
                                <motion.div
                                    initial={{ opacity: 0.8 }}
                                    animate={{ opacity: 0 }}
                                    transition={{ duration: 2, delay: 1 }}
                                    style={{ 
                                        transform: 'translateZ(0)',
                                        maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)',
                                        WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)'
                                    }}
                                    className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-hidden pointer-events-none"
                                >
                                    <span className="carved-deep w-full">{worry}</span>
                                </motion.div>
                            </div>
                            <motion.div
                                initial={{ opacity: 0, scale: 1.1 }} 
                                animate={{ opacity: 0.7, scale: 1 }}
                                transition={{ duration: 4, ease: "easeOut", delay: 0.5 }}
                                className="absolute inset-0 z-30 mix-blend-multiply"
                                style={{
                                    borderRadius: stoneShape,
                                    backgroundColor: '#4A5D23',
                                    filter: 'url(#mossRoughness)'
                                }}
                            />
                            <motion.div
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 0.6 }}
                                transition={{ duration: 3, delay: 1.8 }}
                                className="absolute inset-0 z-40 mix-blend-overlay"
                                style={{ 
                                    borderRadius: stoneShape,
                                    backgroundColor: '#8A9A5B',
                                    backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")`
                                }}
                            />
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex justify-center pt-12">
                            <motion.p 
                                initial={{ opacity: 0 }}
                                animate={{ opacity: [0, 1, 0] }}
                                transition={{ duration: 4, times: [0, 0.5, 1] }}
                                className="text-moss text-sm font-serif whitespace-nowrap"
                            >
                                正在回归大地...
                            </motion.p>
                        </div>
                    </motion.div>
                </div>
            );
        };

        // --- Echo (回响) ---
        const Echo = ({ insight, stoneShape, onReturn }) => {
            const randomID = useMemo(() => 
                Math.random().toString(36).substring(2, 8).toUpperCase(), 
            []);
            const currentDate = useMemo(() => {
                const d = new Date();
                return `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear().toString().substr(-2)} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }, []);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 bg-black/5 overflow-hidden relative">
                    <motion.div
                        initial={{ scale: 1.5, y: 0, opacity: 1 }}
                        animate={{ scale: 0.6, y: -120, opacity: 0.8 }} 
                        transition={{ duration: 1.5, type: "spring", bounce: 0.2 }}
                        className="absolute pointer-events-none grayscale opacity-10 z-0"
                    >
                        <Stone shape={stoneShape} isMossy size="md" />
                    </motion.div>
                    <motion.div
                        drag
                        dragConstraints={{ left: -100, right: 100, top: -100, bottom: 100 }}
                        
                        whileDrag={{ scale: 1, rotate: 0 }} 
                        
                        dragElastic={0.1}
                        initial={{ opacity: 0, y: 20, rotate: -5 }} 
                        animate={{ opacity: 1, y: 20, rotate: 1 }}
                        transition={{ delay: 0.5, duration: 0.8, type: "spring" }}
                        className="relative z-20 bg-[#Fdfdfd] text-ink w-64 max-w-sm drop-shadow-jagged cursor-grab active:cursor-grabbing"
                        style={{ transformOrigin: "center center" }}
                    >
                        <div className="absolute top-[-8px] left-0 w-full h-[8px] jagged-top"></div>
                        <div className="absolute bottom-[-8px] left-0 w-full h-[8px] jagged-bottom"></div>
                        <button 
                            onClick={onReturn}
                            className="absolute top-2 right-2 text-ink/40 hover:text-red-500 transition-colors z-30 p-2"
                        >
                            <Icons.X size={16} />
                        </button>
                        <div className="p-5 pb-6 font-sans">
                            <div className="text-center mb-4">
                                <h3 className="text-xs font-bold tracking-[0.2em] uppercase text-ink/80">Pager Message</h3>
                            </div>
                            <div className="flex justify-between items-end text-[9px] text-ink/50 mb-2 font-bold tracking-wide">
                                <span>ID: {randomID}</span>
                                <span>{currentDate}</span>
                            </div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-4"></div>
                            <div className="min-h-[100px] flex items-center justify-center">
                                <p 
    className="text-base font-bold leading-relaxed text-ink text-left w-full select-none"
    style={{ textWrap: 'balance' }} 
>
    {insight}
</p>
                            </div>
                            <div className="h-4"></div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-3"></div>
                            <div className="flex justify-between items-center opacity-60">
                                <div className="flex items-end gap-[2px] h-6 overflow-hidden">
                                    {[...Array(15)].map((_, i) => (
                                        <div 
                                            key={i} 
                                            className="bg-ink" 
                                            style={{ width: Math.random() > 0.6 ? '1px' : '2px', height: '100%' }}
                                        ></div>
                                    ))}
                                </div>
                                <span className="text-[8px] tracking-widest uppercase font-bold">End of Transmission</span>
                            </div>
                        </div>
                    </motion.div>
                    <motion.p
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 2 }}
                        className="absolute bottom-12 text-xs font-serif text-ink/40 tracking-widest pointer-events-none"
                    >
                        拖拽纸条 · 点击 × 收入口袋
                    </motion.p>
                </div>
            );
        };

        // --- App ---
        const App = () => {
            // ==========================================
            // 1. 状态定义 (保持不变)
            // ==========================================
            const [screen, setScreen] = useState(ScreenState.COURTYARD);
            const [stones, setStones] = useState([]);
            // 装饰物列表
            const [gardenItems, setGardenItems] = useState([]);
            
            const [currentShape, setCurrentShape] = useState(generateOrganicShape());
            const [currentWorry, setCurrentWorry] = useState('');
            const [currentWeather, setCurrentWeather] = useState(Weather.SUN);
            const [currentInsight, setCurrentInsight] = useState('');

            // ==========================================
            // 2. 核心逻辑处理
            // ==========================================

            const handleStart = (weather) => {
                setCurrentWeather(weather);
                setCurrentShape(generateOrganicShape());
                setScreen(ScreenState.ETCHING);
            };

            const handleLayDown = useCallback(async (text) => {
                setCurrentWorry(text);
                setScreen(ScreenState.OVERGROWTH);
                try {
                    const insight = await generateInsight(text, currentWeather);
                    setCurrentInsight(insight);
                } catch (e) {
                    setCurrentInsight("风吹过青苔的声音。");
                }
            }, [currentWeather]);

            const handleGrowthComplete = () => {
                setScreen(ScreenState.ECHO);
            };

            const handleReturn = () => {
                const newStone = {
                    id: Date.now().toString(),
                    worry: currentWorry,
                    insight: currentInsight,
                    timestamp: Date.now(),
                    weather: currentWeather,
                    shapePolygon: currentShape,
                    rotation: Math.random() * 30 - 15,
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 200 - 100
                };
                
                setStones(prevStones => [...prevStones, newStone]);
                
                setScreen(ScreenState.COURTYARD);
                setCurrentWorry('');
                setCurrentInsight('');
            };

           // 【核心修改】转化逻辑升级：智能构图算法
            const handleTransformStones = (targetStoneIds) => {
                // 安全检查
                if (!targetStoneIds || targetStoneIds.length < 9) return;

                // 1. 随机选一种装饰物类型
                const types = ['Lantern', 'Pine', 'Bamboo'];
                const randomType = types[Math.floor(Math.random() * types.length)];

                // =====================================================
                // 2. 智能布局：定义 6 个“风水宝地” (避开屏幕中心区域)
                // =====================================================
                const aestheticZones = [
                    { name: '左上角', xRange: [5, 20],  yRange: [10, 25] }, 
                    { name: '右上角', xRange: [80, 95], yRange: [10, 25] }, 
                    { name: '左下角', xRange: [5, 25],  yRange: [70, 85] }, 
                    { name: '右下角', xRange: [75, 95], yRange: [70, 85] }, 
                    { name: '左边缘', xRange: [2, 12],  yRange: [35, 65] }, 
                    { name: '右边缘', xRange: [88, 98], yRange: [35, 65] }, 
                ];

                // 随机选一个区域
                const zone = aestheticZones[Math.floor(Math.random() * aestheticZones.length)];

                // 在该区域内进行微调
                const finalX = zone.xRange[0] + Math.random() * (zone.xRange[1] - zone.xRange[0]);
                const finalY = zone.yRange[0] + Math.random() * (zone.yRange[1] - zone.yRange[0]);

                const newItem = {
                    id: Date.now(),
                    type: randomType,
                    x: finalX,
                    y: finalY,
                    // 稍微大一点，更有气势
                    scale: 0.9 + Math.random() * 0.5 
                };

                // 3. 添加装饰物
                setGardenItems(prev => [...prev, newItem]);
                
                // 4. 精准删除石头
                setStones(prev => prev.filter(s => !targetStoneIds.includes(s.id)));
                
                // 播放音效
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                playSound('lift'); 
            };

            // ==========================================
            // 3. 视图渲染
            // ==========================================
            return (
                <main className="w-full h-screen overflow-hidden bg-concrete text-ink font-sans selection:bg-moss selection:text-white relative">
                    <AnimatePresence mode="wait">
                        {screen === ScreenState.COURTYARD && (
                            <motion.div key="courtyard" className="w-full h-full" exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Courtyard 
                                    stones={stones} 
                                    onStart={handleStart} 
                                    onUpdateStones={setStones}
                                    
                                    /* 传递装饰物数据 */
                                    gardenItems={gardenItems}
                                    /* 传递新的转化函数 */
                                    onTransform={handleTransformStones}
                                />
                            </motion.div>
                        )}

                        {screen === ScreenState.ETCHING && (
                            <motion.div key="etching" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Etching stoneShape={currentShape} onLayDown={handleLayDown} />
                            </motion.div>
                        )}

                        {screen === ScreenState.OVERGROWTH && (
                            <motion.div key="overgrowth" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.8 } }}>
                                <Overgrowth worry={currentWorry} stoneShape={currentShape} onGrowthComplete={handleGrowthComplete} />
                            </motion.div>
                        )}

                        {screen === ScreenState.ECHO && (
                            <motion.div key="echo" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Echo insight={currentInsight} stoneShape={currentShape} onReturn={handleReturn} />
                            </motion.div>
                        )}
                    </AnimatePresence>
                </main>
            );
        };

                

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
