<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Moss & Stone</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              concrete: '#E0E0E0',
              'concrete-dark': '#C0C0C0',
              moss: '#3A4D1F',
              'moss-light': '#7B924A',
              ink: '#2C2C2C',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              serif: ['"Noto Serif SC"', 'serif'],
            },
          },
        },
      }
    </script>

    <style>
      body {
        background-color: #E0E0E0;
        color: #2C2C2C;
        overflow: hidden; /* 防止 Body 滚动，交由内部容器滚动 */
        touch-action: none;
      }
      
      .noise-bg {
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        pointer-events: none; z-index: 50; opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }

      .carved-deep {
        color: rgba(44, 44, 44, 0.65) !important;
        text-shadow: 
            0px 1px 0px rgba(255,255,255, 0.6), 
            0px -1px 1px rgba(0,0,0, 0.2) !important;
        transition: all 1s ease-out;
      }

      textarea:focus, input:focus {
        outline: none !important;
        box-shadow: none !important;
        border: none !important;
      }
      
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { 
          -ms-overflow-style: none;
          scrollbar-width: none;
      }

      .jagged-top {
          background-image: 
              linear-gradient(45deg, transparent 50%, #Fdfdfd 50%), 
              linear-gradient(-45deg, transparent 50%, #Fdfdfd 50%);
          background-position: bottom left;
          background-size: 10px 10px;
          background-repeat: repeat-x;
      }

      .jagged-bottom {
          background-image: 
              linear-gradient(135deg, transparent 50%, #Fdfdfd 50%), 
              linear-gradient(-135deg, transparent 50%, #Fdfdfd 50%);
          background-position: top left;
          background-size: 10px 10px;
          background-repeat: repeat-x;
      }
      
      .drop-shadow-jagged {
          filter: drop-shadow(4px 4px 10px rgba(0,0,0,0.15));
      }

      /* 庭院滚动容器样式 */
      .courtyard-scroll-container {
          height: 100vh;
          overflow-y: auto;
          scroll-snap-type: y mandatory;
          scroll-behavior: smooth;
      }
      
      .courtyard-page {
          height: 100vh;
          width: 100%;
          scroll-snap-align: start;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden; /* 限制石头拖拽不出界 */
      }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="noise-bg"></div>
    
    <svg style="display: none;">
        <defs>
            <filter id="mossRoughness">
                <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch" />
                <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 1.2 -0.2" />
            </filter>
            <filter id="mossFuzz">
                <feTurbulence type="fractalNoise" baseFrequency="2.5" numOctaves="3" stitchTiles="stitch" />
                <feContrast in="SourceGraphic" mode="linear" slope="2" />
            </filter>
        </defs>
    </svg>

    <script type="text/babel">
        // ==========================================
        // 0. 配置区域
        // ==========================================
        const INSIGHT_POOL = [
            "风吹过，痕迹变淡，但石头记得。",
            "有些重量，放下后才能看清形状。",
            "青苔不急于生长，它只是覆盖。",
            "如同雨水归于大海，情绪也终将平静。",
            "静默是最大的回响。",
            "此刻的粗糙，是未来圆润的开始。",
            "不要慌张，月亮也经常失眠。",
            "山谷没有回音，是因为它在倾听。"
        ];

// ==========================================
// 替换后的生成式音效系统 (不需要 mp3 文件)
// ==========================================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// 生成白噪声缓存
const bufferSize = audioCtx.sampleRate * 2; 
const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
const output = noiseBuffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
}

const playSound = (type, volume = 1.0) => {
    const runAudioLogic = () => {
        const t = audioCtx.currentTime;
        const gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);

        if (type === 'lift') {
            // --- 抬起 ---
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;
            source.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(150, t);
            
            source.connect(filter);
            filter.connect(gainNode);
            
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.1, t + 0.1); 
            gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            
            source.start(t);
            source.stop(t + 0.35);
            
        } else if (type === 'drop') {
            // --- 放下 ---
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            
            osc.frequency.setValueAtTime(90, t);
            osc.frequency.exponentialRampToValueAtTime(30, t + 0.12);
            
            gainNode.gain.setValueAtTime(0.5, t);
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
            
            osc.connect(gainNode);
            osc.start(t);
            osc.stop(t + 0.7);

       } else if (type === 'organize') {
            // --- 整理 (保留原有代码) ---
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, t);
            
            source.connect(filter);
            filter.connect(gainNode);
            
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.1, t + 0.02); 
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.6); 
            
            source.start(t);
            source.stop(t + 0.7);

        // ===============================================
        //  ▼▼▼ 这里是新加入的“凿字”音效 ▼▼▼
        // ===============================================
        } else if (type === 'carve') {
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer;

            // 【修改点】使用 Lowpass (低通)，模拟沉闷的机械键盘声
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass'; 
            // 频率设为 800Hz - 1200Hz，这个范围听起来像敲击实木或厚塑料
            filter.frequency.setValueAtTime(1000, t); 
            
            source.connect(filter);
            filter.connect(gainNode);


            const peakGain = 0.6 * volume;

            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(peakGain, t + 0.005); 
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.04); 

            source.start(t);
            source.stop(t + 0.05);
        }
    };

    // 2. 检查引擎状态：
    // 如果是“挂起/休眠”状态 (suspended)，先唤醒，等唤醒成功(.then)后再发声
    if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
            runAudioLogic();
        });
    } else {
        // 如果已经是“运行中” (running)，直接发声
        runAudioLogic();
    }
};
        // ==========================================
        // 1. 工具函数
        // ==========================================
        const { motion, AnimatePresence } = window.Motion;
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        const Icons = {
            Sun: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="5"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M4.22 4.22l1.42 1.42"/><path d="M18.36 18.36l1.42 1.42"/><path d="M1 12h2"/><path d="M21 12h2"/><path d="M4.22 19.78l1.42-1.42"/><path d="M18.36 5.64l1.42-1.42"/></svg>,
            Cloud: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>,
            CloudRain: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 13v8"/><path d="M8 13v8"/><path d="M12 15v8"/><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"/></svg>,
            CloudLightning: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 16.326A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 .5 8.973"/><path d="m13 12-3 5h4l-3 5"/></svg>,
            X: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>,
            Trash: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Grid: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
            Broom: ({size=24, className}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M16 2l-4 14"/><path d="M2 16h20"/><path d="M6 16v6"/><path d="M10 16v6"/><path d="M14 16v6"/><path d="M18 16v6"/></svg>
        };

        const ScreenState = {
            COURTYARD: 'COURTYARD',
            ETCHING: 'ETCHING',
            OVERGROWTH: 'OVERGROWTH',
            ECHO: 'ECHO'
        };

        const Weather = {
            SUN: 'Sun',
            CLOUD: 'Cloud',
            RAIN: 'Rain',
            STORM: 'Storm'
        };

        const generateOrganicShape = () => {
            const r = () => 30 + Math.random() * 40; 
            return `${r()}% ${r()}% ${r()}% ${r()}% / ${r()}% ${r()}% ${r()}% ${r()}%`;
        };

        const generateInsight = async (text) => {
            return new Promise(resolve => {
                const randomInsight = INSIGHT_POOL[Math.floor(Math.random() * INSIGHT_POOL.length)];
                setTimeout(() => resolve(randomInsight), 2000);
            });
        };

        const chunkArray = (array, size) => {
            const chunked_arr = [];
            for (let i = 0; i < array.length; i += size) {
                chunked_arr.push(array.slice(i, i + size));
            }
            return chunked_arr;
        };

        // ==========================================
        // 2. 基础组件 Stone (已修复输入框点击问题)
        // ==========================================
        const Stone = ({ shape, size = 'md', isMossy = false, className = '', onClick, children, style }) => {
            const sizeClasses = {
                sm: 'w-16 h-16',
                md: 'w-32 h-32',
                lg: 'w-80 h-80' 
            };
            
            const thickShadowStyle = `
                inset 2px 2px 10px rgba(255,255,255, 0.8), 
                inset -3px -3px 15px rgba(0,0,0, 0.25), 
                0px 5px 5px rgba(0,0,0, 0.15), 
                0px 12px 20px rgba(0,0,0, 0.1), 
                0px 25px 40px rgba(0,0,0, 0.1)
            `;

            return (
                <div 
                    onClick={onClick}
                    className={`relative bg-[#d4d4d4] overflow-hidden cursor-grab active:cursor-grabbing transition-all duration-300 ease-out ${sizeClasses[size]} ${className}`}
                    style={{ 
                        borderRadius: shape,
                        boxShadow: thickShadowStyle,
                        transform: 'translateZ(0) perspective(500px) rotateX(2deg)',
                        backfaceVisibility: 'hidden',
                        ...style
                    }}
                >
                    <div className="absolute inset-0 opacity-20 pointer-events-none z-0" 
                         style={{
                             backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`
                         }}
                    ></div>

                    {isMossy && (
                        <>
                            <div className="absolute inset-0 z-10 opacity-70 mix-blend-multiply pointer-events-none"
                                 style={{
                                    backgroundColor: '#4A5D23',
                                    filter: 'url(#mossRoughness) contrast(1.2)',
                                    transform: 'scale(1.02)'
                                 }}
                            ></div>
                            <div className="absolute inset-0 z-10 opacity-60 mix-blend-overlay pointer-events-none"
                                 style={{
                                     backgroundColor: '#8A9A5B',
                                     backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")`,
                                     boxShadow: 'inset 5px 5px 20px rgba(255,255,255,0.3)'
                                 }}
                            ></div>
                             <div className="absolute inset-0 z-10 pointer-events-none opacity-40 mix-blend-multiply"
                                 style={{
                                     background: 'radial-gradient(circle at 30% 30%, transparent 40%, #1a260e 100%)'
                                 }}
                            ></div>
                        </>
                    )}

                    {/* 【关键修改】这里去掉了 pointer-events-none 
                        保证输入框（textarea）可以被点击聚焦
                    */}
                    <div className="relative z-20 w-full h-full">
                        {children}
                    </div>
                </div>
            );
        };

        // ==========================================
        // 3. 核心页面组件
        // ==========================================

// --- Courtyard (庭院 - 无限分页 + 自动滚动版) ---
        const Courtyard = ({ stones, onStart, onUpdateStones }) => {
            // 1. 定义一个 state 来强制刷新（当窗口大小改变时）
            const [windowSize, setWindowSize] = useState({
                w: window.innerWidth,
                h: window.innerHeight
            });

            // 2. 监听窗口调整，实时更新边界
            useEffect(() => {
                const handleResize = () => {
                    setWindowSize({
                        w: window.innerWidth,
                        h: window.innerHeight
                    });
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // 3. 计算边界 (基于实时窗口大小 windowSize)
            const xLimit = windowSize.w / 2 - 60;
            const yLimit = windowSize.h / 2 - 90;

            const [isSelectorOpen, setIsSelectorOpen] = useState(false);
            const [selectedStone, setSelectedStone] = useState(null);
            const [currentPageIndex, setCurrentPageIndex] = useState(0);
            const [showClearConfirm, setShowClearConfirm] = useState(false);
            
            // 标记是否正在拖拽，防止拖拽结束时误触点击
            const isDraggingRef = useRef(false);

            const scrollContainerRef = useRef(null);
            const pageRefs = useRef([]);

          // ==========================================
            // 【修改 1】石头分组逻辑（包含页面防塌陷修复）
            // ==========================================
            const stoneChunks = useMemo(() => {
                const sorted = [...stones]; 
                const chunks = chunkArray(sorted, 9);
                
                // 如果没有石头，至少保留一页空页面
                if (chunks.length === 0) chunks.push([]);

                // 【关键修复】
                // 只要当前的 chunks 数量少于你所在的页码 (currentPageIndex)，
                // 就强行往后填充空数组。
                // 这样当你点击“清空所有”时，你所在的页面容器不会瞬间消失，
                // 而是变成一个空页面，给石头留出播放“下沉动画”的时间。
                while (chunks.length <= currentPageIndex) {
                    chunks.push([]);
                }

                return chunks;
            }, [stones, currentPageIndex]); // 注意：这里加了 currentPageIndex 依赖

            // ==========================================
            // 【核心逻辑 2】自动滚动
            // 当页面数量增加时（产生了第10个、第19个...石头），自动滑到最新的一页
	    // ==========================================
            
            // 定义一个缓动滚动函数
            const smoothScrollTo = (element, target, duration) => {
                const start = element.scrollTop;
                const change = target - start;
                const startTime = performance.now();
                
                // 临时禁用 CSS 滚动吸附，防止它和动画打架
                element.style.scrollSnapType = 'none';

                const animateScroll = (currentTime) => {
                    const timeElapsed = currentTime - startTime;
                    if (timeElapsed < duration) {
                        // 使用 easeInOutQuad 缓动曲线：慢-快-慢
                        const progress = timeElapsed / duration;
                        const ease = progress < 0.5 
                            ? 2 * progress * progress 
                            : -1 + (4 - 2 * progress) * progress;
                        
                        element.scrollTop = start + (change * ease);
                        requestAnimationFrame(animateScroll);
                    } else {
                        element.scrollTop = target;
                        // 动画结束后，恢复 CSS 滚动吸附
                        element.style.scrollSnapType = 'y mandatory';
                    }
                };
                requestAnimationFrame(animateScroll);
            };

            useEffect(() => {
                // 只有当存在多页时才处理
                if (stoneChunks.length > 1) {
                    const lastPageIndex = stoneChunks.length - 1;
                    const container = scrollContainerRef.current;
                    
                    if (container) {
                        const pageHeight = container.clientHeight;
                        const targetScrollTop = lastPageIndex * pageHeight;
                        const prevPageScrollTop = (lastPageIndex - 1) * pageHeight;

                        // 【关键修改 1】
                        // 必须强制把 CSS 里的 scroll-behavior: smooth 关掉！
                        // 否则浏览器会把我们的“瞬移”指令变成“从头开始的慢动作播放”。
                        container.style.scrollBehavior = 'auto'; 

                        // 【关键修改 2】
                        // 执行瞬移：如果当前在顶部，直接跳到上一页的位置
                        if (container.scrollTop < 10) {
                             container.scrollTop = prevPageScrollTop;
                        }

                        // 【关键修改 3】
                        // 开始 JS 手动动画 (从上一页滑向当前页)
                        // 动画函数内部会自己处理每一帧的滚动，不需要 CSS 插手
                        smoothScrollTo(container, targetScrollTop, 1500); 
                    }
                }
            }, [stones.length, stoneChunks.length]);

            const weatherOptions = [
                { type: Weather.SUN, icon: Icons.Sun, label: "晴朗" },
                { type: Weather.CLOUD, icon: Icons.Cloud, label: "多云" },
                { type: Weather.RAIN, icon: Icons.CloudRain, label: "雨天" },
                { type: Weather.STORM, icon: Icons.CloudLightning, label: "风暴" },
            ];

            const formatDate = (timestamp) => {
                return new Date(timestamp).toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
            };

            const handleScroll = () => {
                if (!scrollContainerRef.current) return;
                const scrollTop = scrollContainerRef.current.scrollTop;
                const height = scrollContainerRef.current.clientHeight;
                const index = Math.round(scrollTop / height);
                setCurrentPageIndex(index);
            };

            const handleDragEnd = (stoneId, info) => {
                const delta = { x: info.offset.x, y: info.offset.y };
                
                onUpdateStones(prev => prev.map(s => {
                    if (s.id === stoneId) {
                        let newX = (s.x || 0) + delta.x;
                        let newY = (s.y || 0) + delta.y;

                        // 边界限制
                        newX = Math.max(-xLimit, Math.min(newX, xLimit));
                        newY = Math.max(-yLimit, Math.min(newY, yLimit));

                        return {
                            ...s,
                            x: newX,
                            y: newY
                        };
                    }
                    return s;
                }));
            };

            const handleOrganize = () => {
		playSound('organize');
                if(stoneChunks[currentPageIndex].length === 0) return;
                const currentChunkStones = stoneChunks[currentPageIndex];
                const gridGap = 110; 
                const startX = -110; 
                const startY = -120; 

                const updates = {};
                
                currentChunkStones.forEach((stone, index) => {
                    const row = Math.floor(index / 3);
                    const col = index % 3;
                    const targetX = startX + col * gridGap;
                    const targetY = startY + row * gridGap;
                    updates[stone.id] = { x: targetX, y: targetY, rotation: 0 };
                });

                onUpdateStones(prev => prev.map(s => {
                    if (updates[s.id]) {
                        return { ...s, ...updates[s.id] };
                    }
                    return s;
                }));
            };

            const handleClear = (type) => {
                if (type === 'current') {
                    const stonesToRemove = stoneChunks[currentPageIndex].map(s => s.id);
                    onUpdateStones(prev => prev.filter(s => !stonesToRemove.includes(s.id)));
                } else if (type === 'all') {
                    onUpdateStones([]);
                }
                setShowClearConfirm(false);
            };

	    // ==========================================
            // 【新增功能】计算每一页的日期范围
            // ==========================================
            const getPageDateRange = (chunk) => {
                if (!chunk || chunk.length === 0) return "";
                
                // 因为 chunk 里的石头是按时间顺序排的
                const firstStone = chunk[0];
                const lastStone = chunk[chunk.length - 1];

                const fmt = (ts) => {
                    const d = new Date(ts);
                    return `${d.getFullYear()}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`;
                };

                const startStr = fmt(firstStone.timestamp);
                const endStr = fmt(lastStone.timestamp);

                // 如果开始和结束是同一天，只显示一个日期
                // 如果跨越了多天，显示 "开始日期 - 结束日期"
                return startStr === endStr ? startStr : `${startStr} - ${endStr}`;
            };

            return (
                <div className="relative w-full h-full">
                    <header className="absolute top-4 left-0 w-full text-center z-20 pointer-events-none">
                        <h1 className="text-3xl font-serif font-bold text-ink opacity-80">苔与石</h1>
                        <p className="text-xs text-ink/60 mt-2 tracking-[0.2em] uppercase">Moss & Stone</p>
                    </header>

{/* ================= 调试用按钮 START (发布前删除) ================= */}
<button
    onClick={() => {
        const newStones = Array.from({ length: 9 }).map((_, i) => ({
            id: `debug-${Date.now()}-${i}`,
            worry: `这是第 ${i + 1} 个测试烦恼`,
            insight: `山谷没有回音，是因为它在倾听 (测试数据 ${i + 1})。`,
            timestamp: Date.now(),
            weather: 'Sun',
            shapePolygon: generateOrganicShape(), 
            rotation: Math.random() * 30 - 15,
            x: Math.random() * 160 - 80, 
            y: Math.random() * 160 - 80
        }));
        onUpdateStones(prev => [...prev, ...newStones]);
    }}
    // 修改点：从 top-4 改为 bottom-4，保持 right-4
    className="absolute bottom-4 right-4 z-50 px-4 py-2 bg-red-500/10 border border-red-500/30 text-red-800/60 text-xs font-bold rounded hover:bg-red-500/20 transition-colors backdrop-blur-md"
>
    [测试] +9 石头
</button>
{/* ================= 调试用按钮 END ================= */}

                    {stones.length > 0 && (
                        <div className="absolute top-6 right-6 z-30 flex gap-4">
                            <button 
                                onClick={handleOrganize}
                                className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-moss transition-all shadow-sm backdrop-blur-sm"
                                title="整理"
                            >
                                <Icons.Grid size={20} />
                            </button>
                            <button 
                                onClick={() => setShowClearConfirm(true)}
                                className="p-2 rounded-full bg-concrete/50 hover:bg-white/80 text-ink/40 hover:text-red-800 transition-all shadow-sm backdrop-blur-sm"
                                title="清扫"
                            >
                                <Icons.Broom size={20} />
                            </button>
                        </div>
                    )}

                    <div 
                        ref={scrollContainerRef}
                        onScroll={handleScroll}
                        className="courtyard-scroll-container no-scrollbar"
                    >
                        {stoneChunks.map((chunk, pageIndex) => (
                            <div 
                                key={pageIndex} 
                                ref={el => pageRefs.current[pageIndex] = el}
                                className="courtyard-page"
                            >
                                <div className="relative w-[340px] h-[340px] md:w-[500px] md:h-[500px]"> 
                                   
                                
                                   <AnimatePresence>
    {chunk.map((stone, i) => (
        <motion.div 
            key={stone.id} 
            
            /* 修改 2：这里删掉了 layout 属性。
               绝对定位(absolute)元素如果加 layout，删除时会试图重排，导致瞬间位移。
            */
            
            drag
            whileDrag={{ scale: 1.05 }} 
            dragMomentum={false}
            dragElastic={0}
            
            // ... (中间的事件处理代码保持不变，不需要动) ...
            onPointerDown={() => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }}
            onDragStart={() => {
                isDraggingRef.current = true;
                playSound('lift'); 
            }}
            onDragEnd={(e, info) => { 
                handleDragEnd(stone.id, info);
                playSound('drop');
                setTimeout(() => isDraggingRef.current = false, 200);
            }}
            onClick={(e) => {
                if (isDraggingRef.current) { e.stopPropagation(); return; }
                if (!isSelectorOpen && !selectedStone) setSelectedStone(stone);
            }}
            // ... (中间代码结束) ...

            transition={{ type: "spring", stiffness: 400, damping: 25 }}
            dragConstraints={{ left: -xLimit, right: xLimit, top: -yLimit, bottom: yLimit }}
            
            initial={{ scale: 0 }}
            animate={{ 
                scale: 1, 
                x: stone.x || 0, 
                y: stone.y || 0, 
                rotate: stone.rotation,
                opacity: 1,
                filter: 'blur(0px)'
            }}
            
            // 下沉动画保持不变（错落感）
            exit={{ 
                opacity: 0,
                scale: 0.9,
                y: (stone.y || 0) + 120, 
                filter: 'blur(10px)', 
                transition: { 
                    duration: 1.5,
                    ease: "easeInOut",
                    delay: i * 0.08 
                }
            }}

            className="absolute left-1/2 top-1/2 -ml-8 -mt-8"
            style={{ zIndex: 10 }}
        >
            <Stone shape={stone.shapePolygon} isMossy size="sm" className="hover:scale-105 transition-transform duration-300 shadow-lg" />
        </motion.div>
    ))}
</AnimatePresence>

                                    {/* 这一段是那个"+"号按钮，不需要动，保留原样即可 */}
                                    {pageIndex === stoneChunks.length - 1 && !isSelectorOpen && !selectedStone && (
                                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none translate-y-64">
                                            {/* ...按钮代码省略，保持不变... */}
                                            <motion.button
                                                initial={{ opacity: 0, scale: 0.9 }}
                                                animate={{ opacity: 1, scale: 1 }}
                                                whileHover={{ scale: 1.02, rotate: 2 }}
                                                whileTap={{ scale: 0.98 }}
                                                onClick={() => setIsSelectorOpen(true)}
                                                className="w-48 h-32 border-4 border-dashed border-ink/10 rounded-[40%_60%_50%_50%/50%_40%_60%_50%] flex items-center justify-center hover:border-ink/30 transition-colors bg-concrete/20 pointer-events-auto"
                                            >
                                                <span className="text-2xl text-ink/20">+</span>
                                            </motion.button>
                                        </div>
                                    )}
                                </div>

                                <div className="absolute bottom-8 left-0 w-full text-center pointer-events-none">

<p className="text-[10px] font-sans font-bold tracking-[0.15em] text-ink/20 mb-1.5 uppercase">
                                        {getPageDateRange(chunk)}
                                    </p>
                                    
<p className="text-xs text-ink/30 font-serif tracking-widest">
                                    {pageIndex === stoneChunks.length - 1 
                                        ? "把心事，放在这里。" 
                                        : "往事已生青苔。" 
                                    }
                                </p>
                                    {stoneChunks.length > 1 && (
                                        <div className="mt-2 flex justify-center gap-1">
                                            {stoneChunks.map((_, i) => (
                                                <div key={i} className={`w-1.5 h-1.5 rounded-full ${i === currentPageIndex ? 'bg-moss' : 'bg-ink/10'}`} />
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>

                    <AnimatePresence>
                        {isSelectorOpen && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm">
                            <motion.div
                                initial={{ y: 50, opacity: 0 }}
                                animate={{ y: 0, opacity: 1 }}
                                exit={{ y: 50, opacity: 0 }}
                                className="bg-[#E8E8E8] p-8 rounded-3xl shadow-2xl w-80 max-w-sm border border-white/40"
                            >
                                <h3 className="text-center text-ink/70 mb-8 font-serif text-lg">此刻内心的天气？</h3>
                                <div className="flex justify-between px-2 mb-4">
                                {weatherOptions.map((option) => (
                                    <button
                                    key={option.type}
                                    onClick={() => { setIsSelectorOpen(false); onStart(option.type); }}
                                    className="flex flex-col items-center gap-3 text-ink/40 hover:text-moss transition-colors group"
                                    >
                                    <div className="p-3 rounded-full bg-white/50 group-hover:bg-white transition-colors shadow-sm">
                                        <option.icon size={24} />
                                    </div>
                                    <span className="text-xs font-serif">{option.label}</span>
                                    </button>
                                ))}
                                </div>
                                <button 
                                    onClick={() => setIsSelectorOpen(false)}
                                    className="w-full mt-8 text-xs text-ink/30 tracking-widest hover:text-ink py-2"
                                >
                                    取消
                                </button>
                            </motion.div>
                            </div>
                        )}
                    </AnimatePresence>

                    <AnimatePresence>
                        {selectedStone && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-concrete/80 backdrop-blur-sm" onClick={() => setSelectedStone(null)}>
                            <motion.div
                                initial={{ scale: 0.95, opacity: 0 }}
                                animate={{ scale: 1, opacity: 1 }}
                                exit={{ scale: 0.95, opacity: 0 }}
                                onClick={(e) => e.stopPropagation()}
                                className="bg-[#F0F0F0] p-8 rounded-2xl shadow-2xl w-80 max-w-sm border border-white/40 relative text-center m-4"
                            >
                                <button 
                                    onClick={() => setSelectedStone(null)}
                                    className="absolute top-4 right-4 text-ink/30 hover:text-ink transition-colors"
                                >
                                    <Icons.X size={20} /> 
                                </button>
                                
                                <div className="mt-4 mb-8">
                                    <p className="text-xs text-ink/40 font-serif tracking-[0.2em] uppercase mb-4">
                                        {formatDate(selectedStone.timestamp)}
                                    </p>
                                    <div className="w-8 h-1 bg-moss/20 mx-auto mb-8 rounded-full"></div>
                                    <p className="font-serif text-xl text-ink leading-loose">
                                        “{selectedStone.insight}”
                                    </p>
                                </div>
                                
                                <div className="pt-6 border-t border-ink/5">
                                    <p className="text-xs text-moss opacity-60 font-serif tracking-widest">
                                        记忆已模糊，但智慧留存。
                                    </p>
                                </div>
                            </motion.div>
                        </div>
                        )}
                    </AnimatePresence>

                    <AnimatePresence>
                        {showClearConfirm && (
                            <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/10 backdrop-blur-sm" onClick={() => setShowClearConfirm(false)}>
                                <motion.div
                                    initial={{ scale: 0.9, opacity: 0 }}
                                    animate={{ scale: 1, opacity: 1 }}
                                    exit={{ scale: 0.9, opacity: 0 }}
                                    onClick={(e) => e.stopPropagation()}
                                    className="bg-[#F0F0F0] p-6 rounded-2xl shadow-xl w-72 text-center border border-white/50"
                                >
                                    <h4 className="text-ink/80 font-serif font-bold mb-4">清扫庭院</h4>
                                    <p className="text-xs text-ink/50 mb-6 font-serif">要扫去哪些记忆？</p>
                                    <div className="flex flex-col gap-3">
                                        <button 
                                            onClick={() => handleClear('current')}
                                            className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-ink/70 text-sm hover:bg-moss/10 hover:text-moss transition-colors"
                                        >
                                            仅清扫当前页面
                                        </button>
                                        <button 
                                            onClick={() => handleClear('all')}
                                            className="py-2.5 px-4 rounded-lg bg-white border border-ink/10 text-red-800/60 text-sm hover:bg-red-50 hover:text-red-800 transition-colors"
                                        >
                                            清空所有
                                        </button>
                                        <button 
                                            onClick={() => setShowClearConfirm(false)}
                                            className="mt-2 text-xs text-ink/30 hover:text-ink/60 transition-colors"
                                        >
                                            取消
                                        </button>
                                    </div>
                                </motion.div>
                            </div>
                        )}
                    </AnimatePresence>
                </div>
            );
        };

        // --- Etching (蚀刻) ---
        const Etching = ({ stoneShape, onLayDown }) => {
            const [text, setText] = useState('');
            const [isCarving, setIsCarving] = useState(false);
            const [carvedIndex, setCarvedIndex] = useState(0); 
            const textareaRef = useRef(null);
            const scrollRef = useRef(null);

            useEffect(() => {
                const timer = setTimeout(() => {
                    if (textareaRef.current) textareaRef.current.focus();
                }, 850);
                return () => clearTimeout(timer);
            }, []);

            useEffect(() => {
                if (isCarving && scrollRef.current) {
                    const element = scrollRef.current;
                    const isOverflowing = element.scrollHeight > element.clientHeight;
                    if (isOverflowing) {
                        element.scrollTop = element.scrollHeight;
                    }
                }
            }, [carvedIndex, isCarving]);

            useEffect(() => {
                if (!isCarving) return;
                
                if (carvedIndex > text.length) {
                    const finishTimer = setTimeout(() => {
                        onLayDown(text);
                    }, 500);
                    return () => clearTimeout(finishTimer);
                }

                // 机械键盘节奏
               let delay;
                const maxDelay = 250;  // 前 5 个字的延迟 (慢速)
                const minDelay = 10;   // 最终最快速度 (极快)
                const accelerationStart = 5; // 从第 5 个字开始加速 (index = 5)

                if (carvedIndex < accelerationStart) {
                    // 前 5 个字保持慢速
                    delay = maxDelay;
                } else {
                    // 从第 5 个字开始，使用指数函数递减延迟
                    const x = carvedIndex - accelerationStart; // x: 0, 1, 2, ...
                    
                    // 衰减系数：数字越大，加速越快。0.5 是一个平衡的快速衰减值。
                    const decayFactor = 0.5; 
                    
                    // 计算新的延迟：maxDelay * e^(-decayFactor * x)
                    // Math.pow(Math.E, -decayFactor * x) 是指数衰减的核心
                    delay = Math.max(
                        minDelay, 
                        maxDelay * Math.pow(Math.E, -decayFactor * x)
                    );
                    
                    // 限制 delay 为整数
                    delay = Math.round(delay);
                }                        

                const timer = setTimeout(() => {
                    // ==========================================
                    // 1. 计算音量 (1-5字递减，6字以后为0)
                    // ==========================================
                    // carvedIndex 是从 0 开始的 (0是第1个字)
                    // 0 -> 1.0
                    // 1 -> 0.8
                    // ...
                    // 4 -> 0.2
                    // 5 -> 0.0 (第6个字)
                    let currentVol = 1.0 - (carvedIndex * 0.2);
                    if (currentVol < 0) currentVol = 0;

                    // 只有当音量大于0时才发声，节省资源
                    if (currentVol > 0) {
                        playSound('carve', currentVol); 
                    }

                    // ==========================================
                    // 2. 解决“绊脚石”：动态调整文字显示延迟
                    // ==========================================
                    // 逻辑：当打字速度(delay)变快时(小于50ms)，
                    // 文字显示的延迟(myManualDelay)直接归零，不再阻碍视觉。
                    // 只有前几个慢字保留 300ms 延迟，制造“沉重感”。
                    const myManualDelay = delay < 50 ? 0 : 300; 
                    
                    // 3. 执行文字显示
                    setTimeout(() => {
                        setCarvedIndex(prev => prev + 1);
                    }, myManualDelay);

                }, delay);

                return () => clearTimeout(timer);
            }, [isCarving, carvedIndex, text, onLayDown]);

            const handleSubmit = () => {
                if (text.trim().length === 0) return;
                
                // 【关键修复】
                // 1. 立刻唤醒 AudioContext
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                // 2. 播放一个“空音效”来预热通道
                // 这能消除首字声音的延迟
                const dummyOsc = audioCtx.createOscillator();
                const dummyGain = audioCtx.createGain();
                dummyGain.gain.value = 0; // 它是静音的
                dummyOsc.connect(dummyGain);
                dummyGain.connect(audioCtx.destination);
                dummyOsc.start();
                dummyOsc.stop(0.1);

                if (textareaRef.current) textareaRef.current.blur();
                
                // 3. 稍微缩短一点等待时间 (50ms -> 10ms)，让反应更灵敏
                setTimeout(() => {
                    setIsCarving(true); 
                    setCarvedIndex(0); 
                }, 10); 
            };

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div
                        initial={{ scale: 0.9, opacity: 0 }}
                        animate={{ scale: 1, opacity: 1 }}
                        transition={{ duration: 0.8, ease: "easeOut" }}
                        className="relative"
                    >
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-20">
                                {!isCarving && (
                                    <textarea
                                        ref={textareaRef}
                                        value={text}
                                        onChange={(e) => setText(e.target.value)}
                                        placeholder="刚才发生了什么？"
                                        maxLength={130}
                                        spellCheck={false}
                                        autoComplete="off"
                                        style={{
                                            textShadow: '0px 1px 0px rgba(255,255,255,0.5)',
                                            caretColor: '#2C2C2C',
                                            outline: 'none', border: 'none', boxShadow: 'none', resize: 'none'
                                        }}
                                        className="no-scrollbar appearance-none border-0 shadow-none w-[75%] h-[55%] py-4 bg-transparent text-center text-[#333] font-serif text-lg leading-relaxed placeholder:text-ink/30 placeholder:italic placeholder:shadow-none overflow-y-auto focus:ring-0"
                                    />
                                )}
                                {isCarving && (
                                    <div 
                                        ref={scrollRef}
                                        style={{ 
                                            transform: 'translateZ(0)',
                                            maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)',
                                            WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)'
                                        }}
                                        className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-y-auto scroll-smooth"
                                    >
                                        {text.split('').map((char, index) => (
                                            <span 
                                                key={index}
                                                className={index < carvedIndex ? "carved-deep" : "opacity-0"}
                                                style={{ transition: 'opacity 0.1s' }}
                                            >
                                                {char}
                                            </span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex flex-col items-center pt-12">
                            <motion.button
                                initial={{ opacity: 0 }}
                                animate={{ opacity: text.length > 0 && !isCarving ? 1 : 0 }}
                                disabled={text.length === 0 || isCarving}
                                onClick={handleSubmit}
                                className="px-8 py-3 bg-transparent border border-ink/20 rounded-full text-ink/60 tracking-widest text-sm font-serif hover:bg-ink/5 transition-all disabled:opacity-0 focus:outline-none focus:ring-0 whitespace-nowrap"
                            >
                                {isCarving ? "刻录中..." : "刻好了，放下吧"}
                            </motion.button>
                            {!isCarving && (
                                <div className="mt-4 text-ink/20 text-xs italic font-serif">
                                    {text.length}/130
                                </div>
                            )}
                        </div>
                    </motion.div>
                </div>
            );
        };

        // --- Overgrowth (生长) ---
        const Overgrowth = ({ worry, stoneShape, onGrowthComplete }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onGrowthComplete();
                }, 5000); 
                return () => clearTimeout(timer);
            }, [onGrowthComplete]);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 pb-20 overflow-hidden"> 
                    <motion.div className="relative">
                        <Stone shape={stoneShape} size="lg" className="overflow-hidden relative">
                            <div className="w-full h-full flex items-center justify-center relative z-0">
                                <motion.div
                                    initial={{ opacity: 0.8 }}
                                    animate={{ opacity: 0 }}
                                    transition={{ duration: 2, delay: 1 }}
                                    style={{ 
                                        transform: 'translateZ(0)',
                                        maskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)',
                                        WebkitMaskImage: 'linear-gradient(to bottom, transparent 0px, black 24px, black calc(100% - 24px), transparent 100%)'
                                    }}
                                    className="no-scrollbar w-[80%] h-[60%] py-6 text-center font-serif text-lg leading-relaxed break-words whitespace-pre-wrap flex flex-wrap justify-center content-start overflow-hidden pointer-events-none"
                                >
                                    <span className="carved-deep w-full">{worry}</span>
                                </motion.div>
                            </div>
                            <motion.div
                                initial={{ opacity: 0, scale: 1.1 }} 
                                animate={{ opacity: 0.7, scale: 1 }}
                                transition={{ duration: 4, ease: "easeOut", delay: 0.5 }}
                                className="absolute inset-0 z-30 mix-blend-multiply"
                                style={{
                                    borderRadius: stoneShape,
                                    backgroundColor: '#4A5D23',
                                    filter: 'url(#mossRoughness)'
                                }}
                            />
                            <motion.div
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 0.6 }}
                                transition={{ duration: 3, delay: 1.8 }}
                                className="absolute inset-0 z-40 mix-blend-overlay"
                                style={{ 
                                    borderRadius: stoneShape,
                                    backgroundColor: '#8A9A5B',
                                    backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='fuzz'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23fuzz)' opacity='0.5'/%3E%3C/svg%3E")`
                                }}
                            />
                        </Stone>
                        <div className="absolute top-full left-0 w-full flex justify-center pt-12">
                            <motion.p 
                                initial={{ opacity: 0 }}
                                animate={{ opacity: [0, 1, 0] }}
                                transition={{ duration: 4, times: [0, 0.5, 1] }}
                                className="text-moss text-sm font-serif whitespace-nowrap"
                            >
                                正在回归大地...
                            </motion.p>
                        </div>
                    </motion.div>
                </div>
            );
        };

        // --- Echo (回响) ---
        const Echo = ({ insight, stoneShape, onReturn }) => {
            const randomID = useMemo(() => 
                Math.random().toString(36).substring(2, 8).toUpperCase(), 
            []);
            const currentDate = useMemo(() => {
                const d = new Date();
                return `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear().toString().substr(-2)} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }, []);

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-6 bg-black/5 overflow-hidden relative">
                    <motion.div
                        initial={{ scale: 1.5, y: 0, opacity: 1 }}
                        animate={{ scale: 0.6, y: -120, opacity: 0.8 }} 
                        transition={{ duration: 1.5, type: "spring", bounce: 0.2 }}
                        className="absolute pointer-events-none grayscale opacity-10 z-0"
                    >
                        <Stone shape={stoneShape} isMossy size="md" />
                    </motion.div>
                    <motion.div
                        drag
                        dragConstraints={{ left: -100, right: 100, top: -100, bottom: 100 }}
                        whileDrag={{ scale: 1.05, rotate: 0 }}
                        dragElastic={0.1}
                        initial={{ opacity: 0, y: 20, rotate: -5 }} 
                        animate={{ opacity: 1, y: 20, rotate: 1 }}
                        transition={{ delay: 0.5, duration: 0.8, type: "spring" }}
                        className="relative z-20 bg-[#Fdfdfd] text-ink w-64 max-w-sm drop-shadow-jagged cursor-grab active:cursor-grabbing"
                        style={{ transformOrigin: "center center" }}
                    >
                        <div className="absolute top-[-8px] left-0 w-full h-[8px] jagged-top"></div>
                        <div className="absolute bottom-[-8px] left-0 w-full h-[8px] jagged-bottom"></div>
                        <button 
                            onClick={onReturn}
                            className="absolute top-2 right-2 text-ink/40 hover:text-red-500 transition-colors z-30 p-2"
                        >
                            <Icons.X size={16} />
                        </button>
                        <div className="p-5 pb-6 font-sans">
                            <div className="text-center mb-4">
                                <h3 className="text-xs font-bold tracking-[0.2em] uppercase text-ink/80">Pager Message</h3>
                            </div>
                            <div className="flex justify-between items-end text-[9px] text-ink/50 mb-2 font-bold tracking-wide">
                                <span>ID: {randomID}</span>
                                <span>{currentDate}</span>
                            </div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-4"></div>
                            <div className="min-h-[100px] flex items-center justify-center">
                                <p 
    className="text-base font-bold leading-relaxed text-ink text-left w-full select-none"
    style={{ textWrap: 'balance' }} 
>
    {insight}
</p>
                            </div>
                            <div className="h-4"></div>
                            <div className="w-full border-b-2 border-dashed border-ink/10 mb-3"></div>
                            <div className="flex justify-between items-center opacity-60">
                                <div className="flex items-end gap-[2px] h-6 overflow-hidden">
                                    {[...Array(15)].map((_, i) => (
                                        <div 
                                            key={i} 
                                            className="bg-ink" 
                                            style={{ width: Math.random() > 0.6 ? '1px' : '2px', height: '100%' }}
                                        ></div>
                                    ))}
                                </div>
                                <span className="text-[8px] tracking-widest uppercase font-bold">End of Transmission</span>
                            </div>
                        </div>
                    </motion.div>
                    <motion.p
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 2 }}
                        className="absolute bottom-12 text-xs font-serif text-ink/40 tracking-widest pointer-events-none"
                    >
                        拖拽纸条 · 点击 × 收入口袋
                    </motion.p>
                </div>
            );
        };

        // --- App ---
        const App = () => {
            const [screen, setScreen] = useState(ScreenState.COURTYARD);
            const [stones, setStones] = useState([]);
            const [currentShape, setCurrentShape] = useState(generateOrganicShape());
            const [currentWorry, setCurrentWorry] = useState('');
            const [currentWeather, setCurrentWeather] = useState(Weather.SUN);
            const [currentInsight, setCurrentInsight] = useState('');

            const handleStart = (weather) => {
                setCurrentWeather(weather);
                setCurrentShape(generateOrganicShape());
                setScreen(ScreenState.ETCHING);
            };

            const handleLayDown = useCallback(async (text) => {
                setCurrentWorry(text);
                setScreen(ScreenState.OVERGROWTH);
                try {
                    const insight = await generateInsight(text);
                    setCurrentInsight(insight);
                } catch (e) {
                    setCurrentInsight("风吹过青苔的声音。");
                }
            }, []);

            const handleGrowthComplete = () => {
                setScreen(ScreenState.ECHO);
            };

            const handleReturn = () => {
                const newStone = {
                    id: Date.now().toString(),
                    worry: currentWorry,
                    insight: currentInsight,
                    timestamp: Date.now(),
                    weather: currentWeather,
                    shapePolygon: currentShape,
                    rotation: Math.random() * 30 - 15,
                    // 初始随机位置（相对于页面中心）
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 200 - 100
                };
                
                // 将新石头添加到列表中（不再限制9个）
                setStones(prevStones => [...prevStones, newStone]);
                
                setScreen(ScreenState.COURTYARD);
                setCurrentWorry('');
                setCurrentInsight('');
            };

            return (
                <main className="w-full h-screen overflow-hidden bg-concrete text-ink font-sans selection:bg-moss selection:text-white relative">
                    <AnimatePresence mode="wait">
                        {screen === ScreenState.COURTYARD && (
                            <motion.div key="courtyard" className="w-full h-full" exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Courtyard stones={stones} onStart={handleStart} onUpdateStones={setStones} />
                            </motion.div>
                        )}

                        {screen === ScreenState.ETCHING && (
                            <motion.div key="etching" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Etching stoneShape={currentShape} onLayDown={handleLayDown} />
                            </motion.div>
                        )}

                        {screen === ScreenState.OVERGROWTH && (
                            <motion.div key="overgrowth" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.8 } }}>
                                <Overgrowth worry={currentWorry} stoneShape={currentShape} onGrowthComplete={handleGrowthComplete} />
                            </motion.div>
                        )}

                        {screen === ScreenState.ECHO && (
                            <motion.div key="echo" className="w-full h-full" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0, transition: { duration: 0.5 } }}>
                                <Echo insight={currentInsight} stoneShape={currentShape} onReturn={handleReturn} />
                            </motion.div>
                        )}
                    </AnimatePresence>
                </main>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
